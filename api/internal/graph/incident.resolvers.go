package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

// Reporter is the resolver for the reporter field.
func (r *incidentResolver) Reporter(ctx context.Context, obj *model.Incident) (*model.User, error) {
	if obj.ReporterID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.ReporterID)
}

// Owner is the resolver for the owner field.
func (r *incidentResolver) Owner(ctx context.Context, obj *model.Incident) (*model.User, error) {
	if obj.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.OwnerID)
}

// Assets is the resolver for the assets field.
func (r *incidentResolver) Assets(ctx context.Context, obj *model.Incident, first *int, after *string) (*model1.AssetConnection, error) {
	return &model1.AssetConnection{Edges: []*model1.AssetEdge{}, PageInfo: &model1.PageInfo{}, TotalCount: 0}, nil
}

// Vulnerabilities is the resolver for the vulnerabilities field.
func (r *incidentResolver) Vulnerabilities(ctx context.Context, obj *model.Incident, first *int, after *string) (*model1.VulnerabilityConnection, error) {
	return &model1.VulnerabilityConnection{Edges: []*model1.VulnerabilityEdge{}, PageInfo: &model1.PageInfo{}, TotalCount: 0}, nil
}

// Actions is the resolver for the actions field.
func (r *incidentResolver) Actions(ctx context.Context, obj *model.Incident) ([]*model.IncidentAction, error) {
	var actions []*model.IncidentAction
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		actions, err = r.IncidentRepo.ListActions(ctx, tx, obj.ID)
		return err
	})
	return actions, err
}

// Comments is the resolver for the comments field.
func (r *incidentResolver) Comments(ctx context.Context, obj *model.Incident, first *int, after *string) (*model1.CommentConnection, error) {
	return r.entityComments(ctx, "incident", obj.ID, first, after)
}

// Evidence is the resolver for the evidence field.
func (r *incidentResolver) Evidence(ctx context.Context, obj *model.Incident, first *int, after *string) (*model1.EvidenceConnection, error) {
	return r.entityEvidence(ctx, "incident", obj.ID, first, after)
}

// Owner is the resolver for the owner field.
func (r *incidentActionResolver) Owner(ctx context.Context, obj *model.IncidentAction) (*model.User, error) {
	if obj.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.OwnerID)
}

// CreateIncident is the resolver for the createIncident field.
func (r *mutationResolver) CreateIncident(ctx context.Context, input model1.CreateIncidentInput) (*model.Incident, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	reporterID, _ := auth.UserIDFromContext(ctx)

	inc := &model.Incident{
		OrgID:            orgID,
		Name:             input.Name,
		Area:             derefStr(input.Area),
		Description:      derefStr(input.Description),
		ImpactSummary:    derefStr(input.ImpactSummary),
		ImpactRating:     derefStr(input.ImpactRating),
		RegulatoryBreach: input.RegulatoryBreach != nil && *input.RegulatoryBreach,
		OwnerID:          input.OwnerID,
		Status:           "new",
		DetectedAt:       input.DetectedAt,
		SLADeadline:      input.SLADeadline,
	}
	if input.ReporterID != nil {
		inc.ReporterID = input.ReporterID
	} else {
		inc.ReporterID = &reporterID
	}
	if input.Classification != nil {
		inc.Classification = input.Classification
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.IncidentRepo.Create(ctx, tx, inc); err != nil {
			return err
		}
		for _, aid := range input.AssetIds {
			if err := r.IncidentRepo.LinkAsset(ctx, tx, inc.ID, aid); err != nil {
				return err
			}
		}
		for _, vid := range input.VulnerabilityIds {
			if err := r.IncidentRepo.LinkVulnerability(ctx, tx, inc.ID, vid); err != nil {
				return err
			}
		}
		return nil
	})
	return inc, err
}

// UpdateIncident is the resolver for the updateIncident field.
func (r *mutationResolver) UpdateIncident(ctx context.Context, id string, input model1.UpdateIncidentInput) (*model.Incident, error) {
	var inc *model.Incident
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		inc, err = r.IncidentRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Name != nil {
			inc.Name = *input.Name
		}
		if input.Area != nil {
			inc.Area = *input.Area
		}
		if input.Description != nil {
			inc.Description = *input.Description
		}
		if input.ImpactSummary != nil {
			inc.ImpactSummary = *input.ImpactSummary
		}
		if input.ImpactRating != nil {
			inc.ImpactRating = *input.ImpactRating
		}
		if input.Classification != nil {
			inc.Classification = input.Classification
		}
		if input.RegulatoryBreach != nil {
			inc.RegulatoryBreach = *input.RegulatoryBreach
		}
		if input.Status != nil {
			inc.Status = *input.Status
		}
		if input.RootCause != nil {
			inc.RootCause = *input.RootCause
		}
		if input.RootCauseCategory != nil {
			inc.RootCauseCategory = *input.RootCauseCategory
		}
		if input.CorrectiveActions != nil {
			inc.CorrectiveActions = *input.CorrectiveActions
		}
		if input.PreventiveActions != nil {
			inc.PreventiveActions = *input.PreventiveActions
		}
		if input.OwnerID != nil {
			inc.OwnerID = input.OwnerID
		}
		if input.ContainedAt != nil {
			inc.ContainedAt = input.ContainedAt
		}
		if input.ResolvedAt != nil {
			inc.ResolvedAt = input.ResolvedAt
		}
		if input.ClosedAt != nil {
			inc.ClosedAt = input.ClosedAt
		}
		return r.IncidentRepo.Update(ctx, tx, inc)
	})
	return inc, err
}

// DeleteIncident is the resolver for the deleteIncident field.
func (r *mutationResolver) DeleteIncident(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.IncidentRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// AddIncidentAction is the resolver for the addIncidentAction field.
func (r *mutationResolver) AddIncidentAction(ctx context.Context, incidentID string, input model1.AddIncidentActionInput) (*model.IncidentAction, error) {
	a := &model.IncidentAction{
		IncidentID:  incidentID,
		ActionType:  input.ActionType,
		Description: input.Description,
		OwnerID:     input.OwnerID,
		DueDate:     input.DueDate,
		Status:      "open",
	}
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.IncidentRepo.CreateAction(ctx, tx, a)
	})
	return a, err
}

// UpdateIncidentAction is the resolver for the updateIncidentAction field.
func (r *mutationResolver) UpdateIncidentAction(ctx context.Context, id string, input model1.UpdateIncidentActionInput) (*model.IncidentAction, error) {
	a := &model.IncidentAction{ID: id}
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if input.Description != nil {
			a.Description = *input.Description
		}
		if input.OwnerID != nil {
			a.OwnerID = input.OwnerID
		}
		if input.DueDate != nil {
			a.DueDate = input.DueDate
		}
		if input.Status != nil {
			a.Status = *input.Status
		}
		return r.IncidentRepo.UpdateAction(ctx, tx, a)
	})
	return a, err
}

// Incidents is the resolver for the incidents field.
func (r *queryResolver) Incidents(ctx context.Context, first *int, after *string, filter *model1.IncidentFilter) (*model1.IncidentConnection, error) {
	params := paginationParams(first, after)
	var repoFilter *repository.IncidentFilter
	if filter != nil {
		repoFilter = &repository.IncidentFilter{
			Status:       filter.Status,
			ImpactRating: filter.ImpactRating,
			OwnerID:      filter.OwnerID,
			Search:       filter.Search,
		}
	}

	var incidents []*model.Incident
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		incidents, pr, err = r.IncidentRepo.List(ctx, tx, params, repoFilter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.IncidentEdge, len(incidents))
	for i, inc := range incidents {
		edges[i] = &model1.IncidentEdge{Cursor: repository.EncodeCursor(i), Node: inc}
	}
	return &model1.IncidentConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// Incident is the resolver for the incident field.
func (r *queryResolver) Incident(ctx context.Context, id string) (*model.Incident, error) {
	var inc *model.Incident
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		inc, err = r.IncidentRepo.GetByID(ctx, tx, id)
		return err
	})
	return inc, err
}

// Incident returns IncidentResolver implementation.
func (r *Resolver) Incident() IncidentResolver { return &incidentResolver{r} }

// IncidentAction returns IncidentActionResolver implementation.
func (r *Resolver) IncidentAction() IncidentActionResolver { return &incidentActionResolver{r} }

type incidentResolver struct{ *Resolver }
type incidentActionResolver struct{ *Resolver }
