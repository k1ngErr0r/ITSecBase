package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/k1ngErr0r/ITSecBase/api/internal/auth"
	model1 "github.com/k1ngErr0r/ITSecBase/api/internal/graph/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/model"
)

// Author is the resolver for the author field.
func (r *commentResolver) Author(ctx context.Context, obj *model.Comment) (*model.User, error) {
	return r.resolveUser(ctx, obj.AuthorID)
}

// FileSize is the resolver for the fileSize field.
func (r *evidenceResolver) FileSize(ctx context.Context, obj *model.Evidence) (int, error) {
	return int(obj.FileSize), nil
}

// UploadedBy is the resolver for the uploadedBy field.
func (r *evidenceResolver) UploadedBy(ctx context.Context, obj *model.Evidence) (*model.User, error) {
	return r.resolveUser(ctx, obj.UploadedBy)
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, input model1.AddCommentInput) (*model.Comment, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	c := &model.Comment{
		OrgID:      orgID,
		EntityType: input.EntityType,
		EntityID:   input.EntityID,
		AuthorID:   userID,
		Body:       input.Body,
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.CommentRepo.Create(ctx, tx, c)
	})
	return c, err
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, body string) (*model.Comment, error) {
	var c *model.Comment
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		c, err = r.CommentRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		c.Body = body
		return r.CommentRepo.Update(ctx, tx, c)
	})
	return c, err
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.CommentRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// AddEvidence is the resolver for the addEvidence field.
func (r *mutationResolver) AddEvidence(ctx context.Context, input model1.AddEvidenceInput) (*model.Evidence, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	e := &model.Evidence{
		OrgID:       orgID,
		EntityType:  input.EntityType,
		EntityID:    input.EntityID,
		FileName:    input.FileName,
		FilePath:    "",
		FileSize:    int64(input.FileSize),
		ContentType: input.ContentType,
		UploadedBy:  userID,
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.EvidenceRepo.Create(ctx, tx, e)
	})
	return e, err
}

// DeleteEvidence is the resolver for the deleteEvidence field.
func (r *mutationResolver) DeleteEvidence(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.EvidenceRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Evidence returns EvidenceResolver implementation.
func (r *Resolver) Evidence() EvidenceResolver { return &evidenceResolver{r} }

type commentResolver struct{ *Resolver }
type evidenceResolver struct{ *Resolver }
