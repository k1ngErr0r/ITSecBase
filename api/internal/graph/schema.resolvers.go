package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model1.LoginInput) (*model1.AuthPayload, error) {
	var result *model1.AuthPayload

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByEmail(ctx, tx, input.Email)
		if err != nil {
			return fmt.Errorf("invalid email or password")
		}

		if user.Status != "active" {
			return fmt.Errorf("account is disabled")
		}

		match, err := auth.ComparePassword(user.PasswordHash, input.Password)
		if err != nil || !match {
			_ = r.UserRepo.IncrementFailedLogin(ctx, tx, user.ID)
			return fmt.Errorf("invalid email or password")
		}

		if user.TOTPEnabled {
			if input.TotpCode == nil {
				return fmt.Errorf("totp_required")
			}
			if !auth.ValidateTOTP(user.TOTPSecret, *input.TotpCode) {
				return fmt.Errorf("invalid TOTP code")
			}
		}

		groups, err := r.UserRepo.GetUserGroups(ctx, tx, user.ID)
		if err != nil {
			return fmt.Errorf("get user groups: %w", err)
		}
		var roles []string
		for _, g := range groups {
			roles = append(roles, g.Name)
		}

		accessToken, err := auth.GenerateAccessToken(
			user.ID, user.OrgID, user.Email, roles,
			r.Config.JWT.Secret, r.Config.JWT.AccessTokenExpiry,
		)
		if err != nil {
			return fmt.Errorf("generate access token: %w", err)
		}

		plainRefresh, hashedRefresh, err := auth.GenerateRefreshToken()
		if err != nil {
			return fmt.Errorf("generate refresh token: %w", err)
		}

		refreshToken := &model.RefreshToken{
			ID:        uuid.New().String(),
			UserID:    user.ID,
			TokenHash: hashedRefresh,
			ExpiresAt: time.Now().Add(r.Config.JWT.RefreshTokenExpiry),
		}
		if err := r.UserRepo.StoreRefreshToken(ctx, tx, refreshToken); err != nil {
			return fmt.Errorf("store refresh token: %w", err)
		}

		_ = r.UserRepo.UpdateLastLogin(ctx, tx, user.ID)

		result = &model1.AuthPayload{
			AccessToken:  accessToken,
			RefreshToken: plainRefresh,
			User:         user,
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return result, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model1.AuthPayload, error) {
	var result *model1.AuthPayload

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		hashed := auth.HashRefreshToken(token)
		rt, err := r.UserRepo.GetRefreshTokenByHash(ctx, tx, hashed)
		if err != nil {
			return fmt.Errorf("invalid refresh token")
		}

		if time.Now().After(rt.ExpiresAt) {
			return fmt.Errorf("refresh token expired")
		}

		if err := r.UserRepo.RevokeRefreshToken(ctx, tx, rt.ID); err != nil {
			return err
		}

		user, err := r.UserRepo.GetByID(ctx, tx, rt.UserID)
		if err != nil {
			return err
		}
		if user.Status != "active" {
			return fmt.Errorf("account is disabled")
		}

		groups, err := r.UserRepo.GetUserGroups(ctx, tx, user.ID)
		if err != nil {
			return err
		}
		var roles []string
		for _, g := range groups {
			roles = append(roles, g.Name)
		}

		accessToken, err := auth.GenerateAccessToken(
			user.ID, user.OrgID, user.Email, roles,
			r.Config.JWT.Secret, r.Config.JWT.AccessTokenExpiry,
		)
		if err != nil {
			return err
		}

		plainRefresh, hashedRefresh, err := auth.GenerateRefreshToken()
		if err != nil {
			return err
		}

		newRT := &model.RefreshToken{
			ID:        uuid.New().String(),
			UserID:    user.ID,
			TokenHash: hashedRefresh,
			ExpiresAt: time.Now().Add(r.Config.JWT.RefreshTokenExpiry),
		}
		if err := r.UserRepo.StoreRefreshToken(ctx, tx, newRT); err != nil {
			return err
		}

		result = &model1.AuthPayload{
			AccessToken:  accessToken,
			RefreshToken: plainRefresh,
			User:         user,
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return result, nil
}

// SetupTotp is the resolver for the setupTotp field.
func (r *mutationResolver) SetupTotp(ctx context.Context) (*model1.TotpSetupPayload, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	var result *model1.TotpSetupPayload
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}

		secret, provisioningURL, err := auth.GenerateTOTPSecret(user.Email)
		if err != nil {
			return err
		}

		backupCodes, err := auth.GenerateBackupCodes(8)
		if err != nil {
			return err
		}

		if err := r.UserRepo.UpdateTOTP(ctx, tx, user.ID, secret, false); err != nil {
			return err
		}

		result = &model1.TotpSetupPayload{
			Secret:          secret,
			ProvisioningURL: provisioningURL,
			BackupCodes:     backupCodes,
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

// VerifyTotp is the resolver for the verifyTotp field.
func (r *mutationResolver) VerifyTotp(ctx context.Context, code string) (*model1.TotpVerifyPayload, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}

		if !auth.ValidateTOTP(user.TOTPSecret, code) {
			return fmt.Errorf("invalid TOTP code")
		}

		return r.UserRepo.UpdateTOTP(ctx, tx, user.ID, user.TOTPSecret, true)
	})
	if err != nil {
		return nil, err
	}
	return &model1.TotpVerifyPayload{Success: true}, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model1.Node, error) {
	var result model1.Node
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		// Try each entity type in turn until one matches the ID
		if u, err := r.UserRepo.GetByID(ctx, tx, id); err == nil {
			result = u
			return nil
		}
		if a, err := r.AssetRepo.GetByID(ctx, tx, id); err == nil {
			result = a
			return nil
		}
		if v, err := r.VulnRepo.GetByID(ctx, tx, id); err == nil {
			result = v
			return nil
		}
		if ri, err := r.RiskRepo.GetByID(ctx, tx, id); err == nil {
			result = ri
			return nil
		}
		if inc, err := r.IncidentRepo.GetByID(ctx, tx, id); err == nil {
			result = inc
			return nil
		}
		if dp, err := r.DrPlanRepo.GetByID(ctx, tx, id); err == nil {
			result = dp
			return nil
		}
		return fmt.Errorf("node not found for id: %s", id)
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (bool, error) {
	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
