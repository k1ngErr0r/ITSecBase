package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model1.LoginInput) (*model1.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: Login - login"))
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model1.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// SetupTotp is the resolver for the setupTotp field.
func (r *mutationResolver) SetupTotp(ctx context.Context) (*model1.TotpSetupPayload, error) {
	panic(fmt.Errorf("not implemented: SetupTotp - setupTotp"))
}

// VerifyTotp is the resolver for the verifyTotp field.
func (r *mutationResolver) VerifyTotp(ctx context.Context, code string) (*model1.TotpVerifyPayload, error) {
	panic(fmt.Errorf("not implemented: VerifyTotp - verifyTotp"))
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model1.Node, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (bool, error) {
	panic(fmt.Errorf("not implemented: Health - health"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *Resolver) Health(ctx context.Context) (bool, error) {
	return true, nil
}
func (r *Resolver) Node(ctx context.Context, id string) (interface{}, error) {
	// Relay node refetch â€” decode the ID to determine the type
	// IDs are plain UUIDs; the resolver tries each entity type
	// In production, use a base64-encoded "Type:UUID" format
	return nil, fmt.Errorf("node lookup not yet implemented for id: %s", id)
}

type AuthPayload struct {
	AccessToken  string      `json:"accessToken"`
	RefreshToken string      `json:"refreshToken"`
	User         *model.User `json:"user"`
}
type TotpSetupPayload struct {
	Secret          string   `json:"secret"`
	ProvisioningURL string   `json:"provisioningUrl"`
	BackupCodes     []string `json:"backupCodes"`
}
type TotpVerifyPayload struct {
	Success bool `json:"success"`
}

func (r *Resolver) Login(ctx context.Context, email, password string, totpCode *string) (*AuthPayload, error) {
	var result *AuthPayload

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByEmail(ctx, tx, email)
		if err != nil {
			return fmt.Errorf("invalid email or password")
		}

		if user.Status != "active" {
			return fmt.Errorf("account is disabled")
		}

		match, err := auth.ComparePassword(user.PasswordHash, password)
		if err != nil || !match {
			_ = r.UserRepo.IncrementFailedLogin(ctx, tx, user.ID)
			return fmt.Errorf("invalid email or password")
		}

		if user.TOTPEnabled {
			if totpCode == nil {
				return fmt.Errorf("totp_required")
			}
			if !auth.ValidateTOTP(user.TOTPSecret, *totpCode) {
				return fmt.Errorf("invalid TOTP code")
			}
		}

		// Get user's roles from groups
		groups, err := r.UserRepo.GetUserGroups(ctx, tx, user.ID)
		if err != nil {
			return fmt.Errorf("get user groups: %w", err)
		}
		var roles []string
		for _, g := range groups {
			roles = append(roles, g.Name)
		}

		accessToken, err := auth.GenerateAccessToken(
			user.ID, user.OrgID, user.Email, roles,
			r.Config.JWT.Secret, r.Config.JWT.AccessTokenExpiry,
		)
		if err != nil {
			return fmt.Errorf("generate access token: %w", err)
		}

		plainRefresh, hashedRefresh, err := auth.GenerateRefreshToken()
		if err != nil {
			return fmt.Errorf("generate refresh token: %w", err)
		}

		refreshToken := &model.RefreshToken{
			ID:        uuid.New().String(),
			UserID:    user.ID,
			TokenHash: hashedRefresh,
			ExpiresAt: time.Now().Add(r.Config.JWT.RefreshTokenExpiry),
		}
		if err := r.UserRepo.StoreRefreshToken(ctx, tx, refreshToken); err != nil {
			return fmt.Errorf("store refresh token: %w", err)
		}

		_ = r.UserRepo.UpdateLastLogin(ctx, tx, user.ID)

		result = &AuthPayload{
			AccessToken:  accessToken,
			RefreshToken: plainRefresh,
			User:         user,
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return result, nil
}
func (r *Resolver) RefreshToken(ctx context.Context, token string) (*AuthPayload, error) {
	var result *AuthPayload

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		hashed := auth.HashRefreshToken(token)
		rt, err := r.UserRepo.GetRefreshTokenByHash(ctx, tx, hashed)
		if err != nil {
			return fmt.Errorf("invalid refresh token")
		}

		if time.Now().After(rt.ExpiresAt) {
			return fmt.Errorf("refresh token expired")
		}

		// Revoke old token
		if err := r.UserRepo.RevokeRefreshToken(ctx, tx, rt.ID); err != nil {
			return err
		}

		user, err := r.UserRepo.GetByID(ctx, tx, rt.UserID)
		if err != nil {
			return err
		}
		if user.Status != "active" {
			return fmt.Errorf("account is disabled")
		}

		groups, err := r.UserRepo.GetUserGroups(ctx, tx, user.ID)
		if err != nil {
			return err
		}
		var roles []string
		for _, g := range groups {
			roles = append(roles, g.Name)
		}

		accessToken, err := auth.GenerateAccessToken(
			user.ID, user.OrgID, user.Email, roles,
			r.Config.JWT.Secret, r.Config.JWT.AccessTokenExpiry,
		)
		if err != nil {
			return err
		}

		plainRefresh, hashedRefresh, err := auth.GenerateRefreshToken()
		if err != nil {
			return err
		}

		newRT := &model.RefreshToken{
			ID:        uuid.New().String(),
			UserID:    user.ID,
			TokenHash: hashedRefresh,
			ExpiresAt: time.Now().Add(r.Config.JWT.RefreshTokenExpiry),
		}
		if err := r.UserRepo.StoreRefreshToken(ctx, tx, newRT); err != nil {
			return err
		}

		result = &AuthPayload{
			AccessToken:  accessToken,
			RefreshToken: plainRefresh,
			User:         user,
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return result, nil
}
func (r *Resolver) SetupTotp(ctx context.Context) (*TotpSetupPayload, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	var result *TotpSetupPayload
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}

		secret, provisioningURL, err := auth.GenerateTOTPSecret(user.Email)
		if err != nil {
			return err
		}

		backupCodes, err := auth.GenerateBackupCodes(8)
		if err != nil {
			return err
		}

		// Store the secret (not yet enabled until verified)
		if err := r.UserRepo.UpdateTOTP(ctx, tx, user.ID, secret, false); err != nil {
			return err
		}

		result = &TotpSetupPayload{
			Secret:          secret,
			ProvisioningURL: provisioningURL,
			BackupCodes:     backupCodes,
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}
func (r *Resolver) VerifyTotp(ctx context.Context, code string) (*TotpVerifyPayload, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}

		if !auth.ValidateTOTP(user.TOTPSecret, code) {
			return fmt.Errorf("invalid TOTP code")
		}

		return r.UserRepo.UpdateTOTP(ctx, tx, user.ID, user.TOTPSecret, true)
	})
	if err != nil {
		return nil, err
	}
	return &TotpVerifyPayload{Success: true}, nil
}
func paginationParams(first *int, after *string) repository.PaginationParams {
	p := repository.PaginationParams{}
	if first != nil {
		p.First = *first
	}
	if after != nil {
		p.After = *after
	}
	return p
}
func toPageInfo(pr repository.PaginationResult) *PageInfo {
	return &PageInfo{
		HasNextPage:     pr.HasNextPage,
		HasPreviousPage: pr.HasPreviousPage,
		StartCursor:     strPtr(pr.StartCursor),
		EndCursor:       strPtr(pr.EndCursor),
	}
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

func strPtr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}
