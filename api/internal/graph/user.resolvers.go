package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/k1ngErr0r/ITSecBase/api/internal/auth"
	model1 "github.com/k1ngErr0r/ITSecBase/api/internal/graph/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/repository"
)

// Members is the resolver for the members field.
func (r *groupResolver) Members(ctx context.Context, obj *model.Group, first *int, after *string) (*model1.UserConnection, error) {
	params := paginationParams(first, after)
	var users []*model.User
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		users, pr, err = r.UserRepo.GetGroupMembers(ctx, tx, obj.ID, params)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.UserEdge, len(users))
	for i, u := range users {
		edges[i] = &model1.UserEdge{Cursor: repository.EncodeCursor(i), Node: u}
	}
	return &model1.UserConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model1.CreateUserInput) (*model.User, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return nil, err
	}

	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	if err := auth.ValidatePasswordStrength(input.Password); err != nil {
		return nil, err
	}

	hashed, err := auth.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("hash password: %w", err)
	}

	user := &model.User{
		OrgID:        orgID,
		Email:        input.Email,
		PasswordHash: hashed,
		DisplayName:  input.DisplayName,
		Status:       "active",
	}
	if input.JobTitle != nil {
		user.JobTitle = *input.JobTitle
	}
	if input.Department != nil {
		user.Department = *input.Department
	}

	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.UserRepo.Create(ctx, tx, user); err != nil {
			return err
		}
		for _, gid := range input.GroupIds {
			if err := r.UserRepo.AddUserToGroup(ctx, tx, user.ID, gid); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model1.UpdateUserInput) (*model.User, error) {
	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.DisplayName != nil {
			user.DisplayName = *input.DisplayName
		}
		if input.JobTitle != nil {
			user.JobTitle = *input.JobTitle
		}
		if input.Department != nil {
			user.Department = *input.Department
		}
		if input.Status != nil {
			user.Status = *input.Status
		}
		return r.UserRepo.Update(ctx, tx, user)
	})
	return user, err
}

// DisableUser is the resolver for the disableUser field.
func (r *mutationResolver) DisableUser(ctx context.Context, id string) (*model.User, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return nil, err
	}
	disabled := "disabled"
	return r.UpdateUser(ctx, id, model1.UpdateUserInput{Status: &disabled})
}

// EnableUser is the resolver for the enableUser field.
func (r *mutationResolver) EnableUser(ctx context.Context, id string) (*model.User, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return nil, err
	}
	active := "active"
	return r.UpdateUser(ctx, id, model1.UpdateUserInput{Status: &active})
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model1.CreateGroupInput) (*model.Group, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return nil, err
	}

	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	g := &model.Group{
		OrgID:       orgID,
		Name:        input.Name,
		Permissions: input.Permissions,
	}
	if input.Description != nil {
		g.Description = *input.Description
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.UserRepo.CreateGroup(ctx, tx, g)
	})
	return g, err
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, input model1.UpdateGroupInput) (*model.Group, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return nil, err
	}

	var g *model.Group
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		g, err = r.UserRepo.GetGroupByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Name != nil {
			g.Name = *input.Name
		}
		if input.Description != nil {
			g.Description = *input.Description
		}
		if input.Permissions != nil {
			g.Permissions = input.Permissions
		}
		return r.UserRepo.UpdateGroup(ctx, tx, g)
	})
	return g, err
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (bool, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return false, err
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.UserRepo.DeleteGroup(ctx, tx, id)
	})
	return err == nil, err
}

// AddUserToGroup is the resolver for the addUserToGroup field.
func (r *mutationResolver) AddUserToGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return false, err
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.UserRepo.AddUserToGroup(ctx, tx, userID, groupID)
	})
	return err == nil, err
}

// RemoveUserFromGroup is the resolver for the removeUserFromGroup field.
func (r *mutationResolver) RemoveUserFromGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	if err := auth.RequireRole(ctx, auth.RoleAdmin); err != nil {
		return false, err
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.UserRepo.RemoveUserFromGroup(ctx, tx, userID, groupID)
	})
	return err == nil, err
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("authentication required")
	}

	if err := auth.ValidatePasswordStrength(newPassword); err != nil {
		return false, err
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		user, err := r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}

		match, err := auth.ComparePassword(user.PasswordHash, currentPassword)
		if err != nil || !match {
			return fmt.Errorf("current password is incorrect")
		}

		hashed, err := auth.HashPassword(newPassword)
		if err != nil {
			return err
		}

		if err := r.UserRepo.UpdatePassword(ctx, tx, userID, hashed); err != nil {
			return err
		}

		return r.UserRepo.RevokeAllUserRefreshTokens(ctx, tx, userID)
	})
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model1.UpdateProfileInput) (*model.User, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, userID)
		if err != nil {
			return err
		}
		if input.DisplayName != nil {
			user.DisplayName = *input.DisplayName
		}
		if input.JobTitle != nil {
			user.JobTitle = *input.JobTitle
		}
		if input.Department != nil {
			user.Department = *input.Department
		}
		if input.ProfilePictureURL != nil {
			user.ProfilePictureURL = *input.ProfilePictureURL
		}
		return r.UserRepo.Update(ctx, tx, user)
	})
	return user, err
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, userID)
		return err
	})
	return user, err
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, first *int, after *string, filter *model1.UserFilter) (*model1.UserConnection, error) {
	params := paginationParams(first, after)

	var repoFilter *repository.UserFilter
	if filter != nil {
		repoFilter = &repository.UserFilter{
			Status:  filter.Status,
			Search:  filter.Search,
			GroupID: filter.GroupID,
		}
	}

	var users []*model.User
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		users, pr, err = r.UserRepo.List(ctx, tx, params, repoFilter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.UserEdge, len(users))
	for i, u := range users {
		edges[i] = &model1.UserEdge{Cursor: repository.EncodeCursor(i), Node: u}
	}
	return &model1.UserConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, first *int, after *string) (*model1.GroupConnection, error) {
	params := paginationParams(first, after)
	var groups []*model.Group
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		groups, pr, err = r.UserRepo.ListGroups(ctx, tx, params)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.GroupEdge, len(groups))
	for i, g := range groups {
		edges[i] = &model1.GroupEdge{Cursor: repository.EncodeCursor(i), Node: g}
	}
	return &model1.GroupConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// Groups is the resolver for the groups field.
func (r *userResolver) Groups(ctx context.Context, obj *model.User, first *int, after *string) (*model1.GroupConnection, error) {
	var groups []*model.Group
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		groups, err = r.UserRepo.GetUserGroups(ctx, tx, obj.ID)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.GroupEdge, len(groups))
	for i, g := range groups {
		edges[i] = &model1.GroupEdge{Cursor: repository.EncodeCursor(i), Node: g}
	}
	return &model1.GroupConnection{
		Edges:      edges,
		PageInfo:   &model1.PageInfo{},
		TotalCount: len(groups),
	}, nil
}

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type groupResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
