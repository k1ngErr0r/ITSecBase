package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

// CreateVulnerability is the resolver for the createVulnerability field.
func (r *mutationResolver) CreateVulnerability(ctx context.Context, input model1.CreateVulnerabilityInput) (*model.Vulnerability, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	v := &model.Vulnerability{
		OrgID:         orgID,
		Title:         input.Title,
		Description:   derefStr(input.Description),
		Source:        derefStr(input.Source),
		Severity:      derefStr(input.Severity),
		Status:        "new",
		CVSSVector:    derefStr(input.CvssVector),
		CVSSScore:     input.CvssScore,
		OwnerID:       input.OwnerID,
		AnalystID:     input.AnalystID,
		DiscoveryDate: input.DiscoveryDate,
		DueDate:       input.DueDate,
		Notes:         derefStr(input.Notes),
	}
	if input.CveIds != nil {
		v.CVEIDs = input.CveIds
	}
	if input.Tags != nil {
		v.Tags = input.Tags
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.VulnRepo.Create(ctx, tx, v); err != nil {
			return err
		}
		for _, aid := range input.AssetIds {
			if err := r.VulnRepo.LinkAsset(ctx, tx, v.ID, aid); err != nil {
				return err
			}
		}
		return nil
	})
	return v, err
}

// UpdateVulnerability is the resolver for the updateVulnerability field.
func (r *mutationResolver) UpdateVulnerability(ctx context.Context, id string, input model1.UpdateVulnerabilityInput) (*model.Vulnerability, error) {
	userID, _ := auth.UserIDFromContext(ctx)
	var v *model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		v, err = r.VulnRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}

		changes := map[string][2]string{}
		if input.Title != nil && *input.Title != v.Title {
			changes["title"] = [2]string{v.Title, *input.Title}
			v.Title = *input.Title
		}
		if input.Severity != nil && *input.Severity != v.Severity {
			changes["severity"] = [2]string{v.Severity, *input.Severity}
			v.Severity = *input.Severity
		}
		if input.Status != nil && *input.Status != v.Status {
			changes["status"] = [2]string{v.Status, *input.Status}
			v.Status = *input.Status
		}
		if input.Description != nil {
			v.Description = *input.Description
		}
		if input.Source != nil {
			v.Source = *input.Source
		}
		if input.CvssScore != nil {
			v.CVSSScore = input.CvssScore
		}
		if input.CvssVector != nil {
			v.CVSSVector = *input.CvssVector
		}
		if input.OwnerID != nil {
			v.OwnerID = input.OwnerID
		}
		if input.AnalystID != nil {
			v.AnalystID = input.AnalystID
		}
		if input.ApproverID != nil {
			v.ApproverID = input.ApproverID
		}
		if input.DueDate != nil {
			v.DueDate = input.DueDate
		}
		if input.ClosureDate != nil {
			v.ClosureDate = input.ClosureDate
		}
		if input.CveIds != nil {
			v.CVEIDs = input.CveIds
		}
		if input.Tags != nil {
			v.Tags = input.Tags
		}
		if input.Notes != nil {
			v.Notes = *input.Notes
		}

		if err := r.VulnRepo.Update(ctx, tx, v); err != nil {
			return err
		}

		for field, vals := range changes {
			h := &model.VulnerabilityHistory{
				VulnerabilityID: v.ID,
				ChangedBy:       userID,
				FieldName:       field,
				OldValue:        vals[0],
				NewValue:        vals[1],
			}
			if err := r.VulnRepo.RecordHistory(ctx, tx, h); err != nil {
				return err
			}
		}
		return nil
	})
	return v, err
}

// DeleteVulnerability is the resolver for the deleteVulnerability field.
func (r *mutationResolver) DeleteVulnerability(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.VulnRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// AssignVulnerabilityOwner is the resolver for the assignVulnerabilityOwner field.
func (r *mutationResolver) AssignVulnerabilityOwner(ctx context.Context, id string, ownerID string) (*model.Vulnerability, error) {
	var v *model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		v, err = r.VulnRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		v.OwnerID = &ownerID
		return r.VulnRepo.Update(ctx, tx, v)
	})
	return v, err
}

// BulkUpdateVulnerabilities is the resolver for the bulkUpdateVulnerabilities field.
func (r *mutationResolver) BulkUpdateVulnerabilities(ctx context.Context, ids []string, input model1.BulkVulnUpdateInput) ([]*model.Vulnerability, error) {
	var results []*model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if input.Status != nil {
			if err := r.VulnRepo.BulkUpdateStatus(ctx, tx, ids, *input.Status); err != nil {
				return err
			}
		}
		for _, id := range ids {
			v, err := r.VulnRepo.GetByID(ctx, tx, id)
			if err != nil {
				return err
			}
			needsUpdate := false
			if input.OwnerID != nil {
				v.OwnerID = input.OwnerID
				needsUpdate = true
			}
			if input.Tags != nil {
				v.Tags = input.Tags
				needsUpdate = true
			}
			if needsUpdate {
				if err := r.VulnRepo.Update(ctx, tx, v); err != nil {
					return err
				}
			}
			results = append(results, v)
		}
		return nil
	})
	return results, err
}

// Vulnerabilities is the resolver for the vulnerabilities field.
func (r *queryResolver) Vulnerabilities(ctx context.Context, first *int, after *string, filter *model1.VulnFilter) (*model1.VulnerabilityConnection, error) {
	params := paginationParams(first, after)
	var repoFilter *repository.VulnFilter
	if filter != nil {
		repoFilter = &repository.VulnFilter{
			Severity: filter.Severity,
			Status:   filter.Status,
			OwnerID:  filter.OwnerID,
			AssetID:  filter.AssetID,
			Search:   filter.Search,
			CveID:    filter.CveID,
		}
	}

	var vulns []*model.Vulnerability
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		vulns, pr, err = r.VulnRepo.List(ctx, tx, params, repoFilter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.VulnerabilityEdge, len(vulns))
	for i, v := range vulns {
		edges[i] = &model1.VulnerabilityEdge{Cursor: repository.EncodeCursor(i), Node: v}
	}
	return &model1.VulnerabilityConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// Vulnerability is the resolver for the vulnerability field.
func (r *queryResolver) Vulnerability(ctx context.Context, id string) (*model.Vulnerability, error) {
	var v *model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		v, err = r.VulnRepo.GetByID(ctx, tx, id)
		return err
	})
	return v, err
}

// ExternalRefs is the resolver for the externalRefs field.
func (r *vulnerabilityResolver) ExternalRefs(ctx context.Context, obj *model.Vulnerability) (*string, error) {
	if obj.ExternalRefs == nil {
		return nil, nil
	}
	s := string(obj.ExternalRefs)
	return &s, nil
}

// Owner is the resolver for the owner field.
func (r *vulnerabilityResolver) Owner(ctx context.Context, obj *model.Vulnerability) (*model.User, error) {
	if obj.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.OwnerID)
}

// Analyst is the resolver for the analyst field.
func (r *vulnerabilityResolver) Analyst(ctx context.Context, obj *model.Vulnerability) (*model.User, error) {
	if obj.AnalystID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.AnalystID)
}

// Approver is the resolver for the approver field.
func (r *vulnerabilityResolver) Approver(ctx context.Context, obj *model.Vulnerability) (*model.User, error) {
	if obj.ApproverID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.ApproverID)
}

// Assets is the resolver for the assets field.
func (r *vulnerabilityResolver) Assets(ctx context.Context, obj *model.Vulnerability, first *int, after *string) (*model1.AssetConnection, error) {
	var assetIDs []string
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		assetIDs, err = r.VulnRepo.GetAssetIDs(ctx, tx, obj.ID)
		return err
	})
	if err != nil || len(assetIDs) == 0 {
		return &model1.AssetConnection{Edges: []*model1.AssetEdge{}, PageInfo: &model1.PageInfo{}, TotalCount: 0}, nil
	}

	var assets []*model.Asset
	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		for _, id := range assetIDs {
			a, err := r.AssetRepo.GetByID(ctx, tx, id)
			if err != nil {
				continue
			}
			assets = append(assets, a)
		}
		return nil
	})

	edges := make([]*model1.AssetEdge, len(assets))
	for i, a := range assets {
		edges[i] = &model1.AssetEdge{Cursor: repository.EncodeCursor(i), Node: a}
	}
	return &model1.AssetConnection{Edges: edges, PageInfo: &model1.PageInfo{}, TotalCount: len(assets)}, nil
}

// Comments is the resolver for the comments field.
func (r *vulnerabilityResolver) Comments(ctx context.Context, obj *model.Vulnerability, first *int, after *string) (*model1.CommentConnection, error) {
	return r.entityComments(ctx, "vulnerability", obj.ID, first, after)
}

// Evidence is the resolver for the evidence field.
func (r *vulnerabilityResolver) Evidence(ctx context.Context, obj *model.Vulnerability, first *int, after *string) (*model1.EvidenceConnection, error) {
	return r.entityEvidence(ctx, "vulnerability", obj.ID, first, after)
}

// History is the resolver for the history field.
func (r *vulnerabilityResolver) History(ctx context.Context, obj *model.Vulnerability, first *int, after *string) (*model1.VulnerabilityHistoryConnection, error) {
	var history []*model.VulnerabilityHistory

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		history, err = r.VulnRepo.GetHistory(ctx, tx, obj.ID)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.VulnerabilityHistoryEdge, len(history))
	for i, h := range history {
		edges[i] = &model1.VulnerabilityHistoryEdge{Cursor: repository.EncodeCursor(i), Node: h}
	}
	return &model1.VulnerabilityHistoryConnection{Edges: edges, PageInfo: &model1.PageInfo{}, TotalCount: len(history)}, nil
}

// ChangedBy is the resolver for the changedBy field.
func (r *vulnerabilityHistoryResolver) ChangedBy(ctx context.Context, obj *model.VulnerabilityHistory) (*model.User, error) {
	if obj.ChangedBy == "" {
		return nil, nil
	}
	return r.resolveUser(ctx, obj.ChangedBy)
}

// Vulnerability returns VulnerabilityResolver implementation.
func (r *Resolver) Vulnerability() VulnerabilityResolver { return &vulnerabilityResolver{r} }

// VulnerabilityHistory returns VulnerabilityHistoryResolver implementation.
func (r *Resolver) VulnerabilityHistory() VulnerabilityHistoryResolver {
	return &vulnerabilityHistoryResolver{r}
}

type vulnerabilityResolver struct{ *Resolver }
type vulnerabilityHistoryResolver struct{ *Resolver }
