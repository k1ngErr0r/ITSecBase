package graph

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

type VulnerabilityConnection struct {
	Edges      []*VulnerabilityEdge `json:"edges"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type VulnerabilityEdge struct {
	Cursor string               `json:"cursor"`
	Node   *model.Vulnerability `json:"node"`
}

func (r *Resolver) Vulnerabilities(ctx context.Context, first *int, after *string, filter *repository.VulnFilter) (*VulnerabilityConnection, error) {
	params := paginationParams(first, after)
	var vulns []*model.Vulnerability
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		vulns, pr, err = r.VulnRepo.List(ctx, tx, params, filter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*VulnerabilityEdge, len(vulns))
	for i, v := range vulns {
		edges[i] = &VulnerabilityEdge{Cursor: repository.EncodeCursor(i), Node: v}
	}
	return &VulnerabilityConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

func (r *Resolver) Vulnerability(ctx context.Context, id string) (*model.Vulnerability, error) {
	var v *model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		v, err = r.VulnRepo.GetByID(ctx, tx, id)
		return err
	})
	return v, err
}

func (r *Resolver) CreateVulnerability(ctx context.Context, input CreateVulnInput) (*model.Vulnerability, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	v := &model.Vulnerability{
		OrgID:       orgID,
		Title:       input.Title,
		Description: derefStr(input.Description),
		Source:      derefStr(input.Source),
		Severity:    derefStr(input.Severity),
		Status:      "new",
	}
	if input.CVEIDs != nil {
		v.CVEIDs = input.CVEIDs
	}
	v.CVSSScore = input.CVSSScore
	v.CVSSVector = derefStr(input.CVSSVector)
	v.OwnerID = input.OwnerID
	v.AnalystID = input.AnalystID
	v.ApproverID = input.ApproverID
	v.DiscoveryDate = input.DiscoveryDate
	v.DueDate = input.DueDate
	if input.Tags != nil {
		v.Tags = input.Tags
	}
	v.Notes = derefStr(input.Notes)

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.VulnRepo.Create(ctx, tx, v); err != nil {
			return err
		}
		for _, aid := range input.AssetIDs {
			if err := r.VulnRepo.LinkAsset(ctx, tx, v.ID, aid); err != nil {
				return err
			}
		}
		return nil
	})
	return v, err
}

func (r *Resolver) UpdateVulnerability(ctx context.Context, id string, input UpdateVulnInput) (*model.Vulnerability, error) {
	userID, _ := auth.UserIDFromContext(ctx)
	var v *model.Vulnerability
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		v, err = r.VulnRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}

		// Track field changes for history
		changes := map[string][2]string{}
		if input.Title != nil && *input.Title != v.Title {
			changes["title"] = [2]string{v.Title, *input.Title}
			v.Title = *input.Title
		}
		if input.Severity != nil && *input.Severity != v.Severity {
			changes["severity"] = [2]string{v.Severity, *input.Severity}
			v.Severity = *input.Severity
		}
		if input.Status != nil && *input.Status != v.Status {
			changes["status"] = [2]string{v.Status, *input.Status}
			v.Status = *input.Status
		}
		if input.Description != nil {
			v.Description = *input.Description
		}
		if input.Source != nil {
			v.Source = *input.Source
		}
		if input.CVSSScore != nil {
			v.CVSSScore = input.CVSSScore
		}
		if input.CVSSVector != nil {
			v.CVSSVector = *input.CVSSVector
		}
		if input.OwnerID != nil {
			v.OwnerID = input.OwnerID
		}
		if input.AnalystID != nil {
			v.AnalystID = input.AnalystID
		}
		if input.ApproverID != nil {
			v.ApproverID = input.ApproverID
		}
		if input.DueDate != nil {
			v.DueDate = input.DueDate
		}
		if input.Tags != nil {
			v.Tags = input.Tags
		}
		if input.Notes != nil {
			v.Notes = *input.Notes
		}

		if err := r.VulnRepo.Update(ctx, tx, v); err != nil {
			return err
		}

		// Record history entries
		for field, vals := range changes {
			h := &model.VulnerabilityHistory{
				VulnerabilityID: v.ID,
				ChangedBy:       userID,
				FieldName:       field,
				OldValue:        vals[0],
				NewValue:        vals[1],
			}
			if err := r.VulnRepo.RecordHistory(ctx, tx, h); err != nil {
				return err
			}
		}
		return nil
	})
	return v, err
}

func (r *Resolver) DeleteVulnerability(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.VulnRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

func (r *Resolver) BulkUpdateVulnerabilities(ctx context.Context, ids []string, status string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.VulnRepo.BulkUpdateStatus(ctx, tx, ids, status)
	})
	return err == nil, err
}

// Field resolvers

func (r *Resolver) VulnerabilityOwner(ctx context.Context, v *model.Vulnerability) (*model.User, error) {
	if v.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *v.OwnerID)
}

func (r *Resolver) VulnerabilityAssets(ctx context.Context, v *model.Vulnerability, first *int, after *string) (*AssetConnection, error) {
	params := paginationParams(first, after)
	assetFilter := &repository.AssetFilter{}

	var assetIDs []string
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		assetIDs, err = r.VulnRepo.GetAssetIDs(ctx, tx, v.ID)
		return err
	})
	if err != nil || len(assetIDs) == 0 {
		return &AssetConnection{Edges: []*AssetEdge{}, PageInfo: &PageInfo{}, TotalCount: 0}, err
	}
	_ = params
	_ = assetFilter

	// Fetch linked assets
	var assets []*model.Asset
	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		for _, id := range assetIDs {
			a, err := r.AssetRepo.GetByID(ctx, tx, id)
			if err != nil {
				continue
			}
			assets = append(assets, a)
		}
		return nil
	})

	edges := make([]*AssetEdge, len(assets))
	for i, a := range assets {
		edges[i] = &AssetEdge{Cursor: repository.EncodeCursor(i), Node: a}
	}
	return &AssetConnection{Edges: edges, PageInfo: &PageInfo{}, TotalCount: len(assets)}, nil
}

func (r *Resolver) VulnerabilityHistory(ctx context.Context, v *model.Vulnerability) ([]*model.VulnerabilityHistory, error) {
	var history []*model.VulnerabilityHistory
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		history, err = r.VulnRepo.GetHistory(ctx, tx, v.ID)
		return err
	})
	return history, err
}

// Helper

func (r *Resolver) resolveUser(ctx context.Context, id string) (*model.User, error) {
	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, id)
		return err
	})
	return user, err
}

func derefStr(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

// Input types

type CreateVulnInput struct {
	Title         string     `json:"title"`
	Description   *string    `json:"description"`
	Source         *string    `json:"source"`
	CVEIDs        []string   `json:"cveIds"`
	CVSSScore     *float64   `json:"cvssScore"`
	CVSSVector    *string    `json:"cvssVector"`
	Severity      *string    `json:"severity"`
	DiscoveryDate *interface{} `json:"discoveryDate"`
	DueDate       *interface{} `json:"dueDate"`
	OwnerID       *string    `json:"ownerId"`
	AnalystID     *string    `json:"analystId"`
	ApproverID    *string    `json:"approverId"`
	Tags          []string   `json:"tags"`
	Notes         *string    `json:"notes"`
	AssetIDs      []string   `json:"assetIds"`
}

type UpdateVulnInput struct {
	Title       *string  `json:"title"`
	Description *string  `json:"description"`
	Source      *string  `json:"source"`
	CVSSScore   *float64 `json:"cvssScore"`
	CVSSVector  *string  `json:"cvssVector"`
	Severity    *string  `json:"severity"`
	Status      *string  `json:"status"`
	DueDate     *interface{} `json:"dueDate"`
	OwnerID     *string  `json:"ownerId"`
	AnalystID   *string  `json:"analystId"`
	ApproverID  *string  `json:"approverId"`
	Tags        []string `json:"tags"`
	Notes       *string  `json:"notes"`
}
