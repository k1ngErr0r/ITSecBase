package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/k1ngErr0r/ITSecBase/api/internal/auth"
	model1 "github.com/k1ngErr0r/ITSecBase/api/internal/graph/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/repository"
)

// Owner is the resolver for the owner field.
func (r *drPlanResolver) Owner(ctx context.Context, obj *model.DrPlan) (*model.User, error) {
	if obj.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.OwnerID)
}

// Assets is the resolver for the assets field.
func (r *drPlanResolver) Assets(ctx context.Context, obj *model.DrPlan, first *int, after *string) (*model1.AssetConnection, error) {
	var assetIDs []string
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		assetIDs, err = r.DrPlanRepo.GetLinkedAssetIDs(ctx, tx, obj.ID)
		return err
	})
	if err != nil || len(assetIDs) == 0 {
		return &model1.AssetConnection{Edges: []*model1.AssetEdge{}, PageInfo: &model1.PageInfo{}, TotalCount: 0}, nil
	}

	var assets []*model.Asset
	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		for _, id := range assetIDs {
			a, err := r.AssetRepo.GetByID(ctx, tx, id)
			if err != nil {
				continue
			}
			assets = append(assets, a)
		}
		return nil
	})

	edges := make([]*model1.AssetEdge, len(assets))
	for i, a := range assets {
		edges[i] = &model1.AssetEdge{Cursor: repository.EncodeCursor(i), Node: a}
	}
	return &model1.AssetConnection{Edges: edges, PageInfo: &model1.PageInfo{}, TotalCount: len(assets)}, nil
}

// Tests is the resolver for the tests field.
func (r *drPlanResolver) Tests(ctx context.Context, obj *model.DrPlan) ([]*model.DrTest, error) {
	var tests []*model.DrTest
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		tests, err = r.DrPlanRepo.ListTests(ctx, tx, obj.ID)
		return err
	})
	return tests, err
}

// Comments is the resolver for the comments field.
func (r *drPlanResolver) Comments(ctx context.Context, obj *model.DrPlan, first *int, after *string) (*model1.CommentConnection, error) {
	return r.entityComments(ctx, "dr_plan", obj.ID, first, after)
}

// Evidence is the resolver for the evidence field.
func (r *drPlanResolver) Evidence(ctx context.Context, obj *model.DrPlan, first *int, after *string) (*model1.EvidenceConnection, error) {
	return r.entityEvidence(ctx, "dr_plan", obj.ID, first, after)
}

// Comments is the resolver for the comments field.
func (r *drTestResolver) Comments(ctx context.Context, obj *model.DrTest, first *int, after *string) (*model1.CommentConnection, error) {
	return r.entityComments(ctx, "dr_test", obj.ID, first, after)
}

// Evidence is the resolver for the evidence field.
func (r *drTestResolver) Evidence(ctx context.Context, obj *model.DrTest, first *int, after *string) (*model1.EvidenceConnection, error) {
	return r.entityEvidence(ctx, "dr_test", obj.ID, first, after)
}

// CreateDrPlan is the resolver for the createDrPlan field.
func (r *mutationResolver) CreateDrPlan(ctx context.Context, input model1.CreateDrPlanInput) (*model.DrPlan, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	p := &model.DrPlan{
		OrgID:      orgID,
		Name:       input.Name,
		Scope:      derefStr(input.Scope),
		OwnerID:    input.OwnerID,
		Version:    derefStr(input.Version),
		RTOMinutes: input.RtoMinutes,
		RPOMinutes: input.RpoMinutes,
		Playbook:   derefStr(input.Playbook),
		Status:     "draft",
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.DrPlanRepo.Create(ctx, tx, p); err != nil {
			return err
		}
		for _, aid := range input.AssetIds {
			if err := r.DrPlanRepo.LinkAsset(ctx, tx, p.ID, aid); err != nil {
				return err
			}
		}
		return nil
	})
	return p, err
}

// UpdateDrPlan is the resolver for the updateDrPlan field.
func (r *mutationResolver) UpdateDrPlan(ctx context.Context, id string, input model1.UpdateDrPlanInput) (*model.DrPlan, error) {
	var p *model.DrPlan
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		p, err = r.DrPlanRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Name != nil {
			p.Name = *input.Name
		}
		if input.Scope != nil {
			p.Scope = *input.Scope
		}
		if input.OwnerID != nil {
			p.OwnerID = input.OwnerID
		}
		if input.Version != nil {
			p.Version = *input.Version
		}
		if input.RtoMinutes != nil {
			p.RTOMinutes = input.RtoMinutes
		}
		if input.RpoMinutes != nil {
			p.RPOMinutes = input.RpoMinutes
		}
		if input.Playbook != nil {
			p.Playbook = *input.Playbook
		}
		if input.Status != nil {
			p.Status = *input.Status
		}
		return r.DrPlanRepo.Update(ctx, tx, p)
	})
	return p, err
}

// DeleteDrPlan is the resolver for the deleteDrPlan field.
func (r *mutationResolver) DeleteDrPlan(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.DrPlanRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// RecordDrTest is the resolver for the recordDrTest field.
func (r *mutationResolver) RecordDrTest(ctx context.Context, planID string, input model1.RecordDrTestInput) (*model.DrTest, error) {
	t := &model.DrTest{
		DrPlanID:     planID,
		TestType:     input.TestType,
		PlannedDate:  input.PlannedDate,
		ActualDate:   input.ActualDate,
		Result:       derefStr(input.Result),
		Observations: derefStr(input.Observations),
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.DrPlanRepo.CreateTest(ctx, tx, t)
	})
	return t, err
}

// UpdateDrTest is the resolver for the updateDrTest field.
func (r *mutationResolver) UpdateDrTest(ctx context.Context, id string, input model1.UpdateDrTestInput) (*model.DrTest, error) {
	t := &model.DrTest{ID: id}
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if input.ActualDate != nil {
			t.ActualDate = input.ActualDate
		}
		if input.Result != nil {
			t.Result = *input.Result
		}
		if input.Observations != nil {
			t.Observations = *input.Observations
		}
		return r.DrPlanRepo.UpdateTest(ctx, tx, t)
	})
	return t, err
}

// DrPlans is the resolver for the drPlans field.
func (r *queryResolver) DrPlans(ctx context.Context, first *int, after *string, filter *model1.DrPlanFilter) (*model1.DrPlanConnection, error) {
	params := paginationParams(first, after)
	var repoFilter *repository.DrPlanFilter
	if filter != nil {
		repoFilter = &repository.DrPlanFilter{
			Status: filter.Status,
			Search: filter.Search,
		}
	}

	var plans []*model.DrPlan
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		plans, pr, err = r.DrPlanRepo.List(ctx, tx, params, repoFilter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.DrPlanEdge, len(plans))
	for i, p := range plans {
		edges[i] = &model1.DrPlanEdge{Cursor: repository.EncodeCursor(i), Node: p}
	}
	return &model1.DrPlanConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// DrPlan is the resolver for the drPlan field.
func (r *queryResolver) DrPlan(ctx context.Context, id string) (*model.DrPlan, error) {
	var p *model.DrPlan
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		p, err = r.DrPlanRepo.GetByID(ctx, tx, id)
		return err
	})
	return p, err
}

// DrPlan returns DrPlanResolver implementation.
func (r *Resolver) DrPlan() DrPlanResolver { return &drPlanResolver{r} }

// DrTest returns DrTestResolver implementation.
func (r *Resolver) DrTest() DrTestResolver { return &drTestResolver{r} }

type drPlanResolver struct{ *Resolver }
type drTestResolver struct{ *Resolver }
