package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

// CreateRisk is the resolver for the createRisk field.
func (r *mutationResolver) CreateRisk(ctx context.Context, input model1.CreateRiskInput) (*model.Risk, error) {
	panic(fmt.Errorf("not implemented: CreateRisk - createRisk"))
}

// UpdateRisk is the resolver for the updateRisk field.
func (r *mutationResolver) UpdateRisk(ctx context.Context, id string, input model1.UpdateRiskInput) (*model.Risk, error) {
	panic(fmt.Errorf("not implemented: UpdateRisk - updateRisk"))
}

// DeleteRisk is the resolver for the deleteRisk field.
func (r *mutationResolver) DeleteRisk(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteRisk - deleteRisk"))
}

// AddRiskTreatment is the resolver for the addRiskTreatment field.
func (r *mutationResolver) AddRiskTreatment(ctx context.Context, riskID string, input model1.AddRiskTreatmentInput) (*model.RiskTreatment, error) {
	panic(fmt.Errorf("not implemented: AddRiskTreatment - addRiskTreatment"))
}

// UpdateRiskTreatment is the resolver for the updateRiskTreatment field.
func (r *mutationResolver) UpdateRiskTreatment(ctx context.Context, id string, input model1.UpdateRiskTreatmentInput) (*model.RiskTreatment, error) {
	panic(fmt.Errorf("not implemented: UpdateRiskTreatment - updateRiskTreatment"))
}

// UpdateRiskMatrixConfig is the resolver for the updateRiskMatrixConfig field.
func (r *mutationResolver) UpdateRiskMatrixConfig(ctx context.Context, input model1.UpdateRiskMatrixConfigInput) (*model.RiskMatrixConfig, error) {
	panic(fmt.Errorf("not implemented: UpdateRiskMatrixConfig - updateRiskMatrixConfig"))
}

// Risks is the resolver for the risks field.
func (r *queryResolver) Risks(ctx context.Context, first *int, after *string, filter *model1.RiskFilter) (*model1.RiskConnection, error) {
	panic(fmt.Errorf("not implemented: Risks - risks"))
}

// Risk is the resolver for the risk field.
func (r *queryResolver) Risk(ctx context.Context, id string) (*model.Risk, error) {
	panic(fmt.Errorf("not implemented: Risk - risk"))
}

// RiskMatrixConfig is the resolver for the riskMatrixConfig field.
func (r *queryResolver) RiskMatrixConfig(ctx context.Context) (*model.RiskMatrixConfig, error) {
	panic(fmt.Errorf("not implemented: RiskMatrixConfig - riskMatrixConfig"))
}

// CalculatedInherentLevel is the resolver for the calculatedInherentLevel field.
func (r *riskResolver) CalculatedInherentLevel(ctx context.Context, obj *model.Risk) (*string, error) {
	panic(fmt.Errorf("not implemented: CalculatedInherentLevel - calculatedInherentLevel"))
}

// CalculatedResidualLevel is the resolver for the calculatedResidualLevel field.
func (r *riskResolver) CalculatedResidualLevel(ctx context.Context, obj *model.Risk) (*string, error) {
	panic(fmt.Errorf("not implemented: CalculatedResidualLevel - calculatedResidualLevel"))
}

// Owner is the resolver for the owner field.
func (r *riskResolver) Owner(ctx context.Context, obj *model.Risk) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Owner - owner"))
}

// Approver is the resolver for the approver field.
func (r *riskResolver) Approver(ctx context.Context, obj *model.Risk) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Approver - approver"))
}

// LastReviewedBy is the resolver for the lastReviewedBy field.
func (r *riskResolver) LastReviewedBy(ctx context.Context, obj *model.Risk) (*model.User, error) {
	panic(fmt.Errorf("not implemented: LastReviewedBy - lastReviewedBy"))
}

// Assets is the resolver for the assets field.
func (r *riskResolver) Assets(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.AssetConnection, error) {
	panic(fmt.Errorf("not implemented: Assets - assets"))
}

// Treatments is the resolver for the treatments field.
func (r *riskResolver) Treatments(ctx context.Context, obj *model.Risk) ([]*model.RiskTreatment, error) {
	panic(fmt.Errorf("not implemented: Treatments - treatments"))
}

// Controls is the resolver for the controls field.
func (r *riskResolver) Controls(ctx context.Context, obj *model.Risk) ([]*model.OrgIsoControl, error) {
	panic(fmt.Errorf("not implemented: Controls - controls"))
}

// Comments is the resolver for the comments field.
func (r *riskResolver) Comments(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.CommentConnection, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// Evidence is the resolver for the evidence field.
func (r *riskResolver) Evidence(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.EvidenceConnection, error) {
	panic(fmt.Errorf("not implemented: Evidence - evidence"))
}

// LikelihoodLabels is the resolver for the likelihoodLabels field.
func (r *riskMatrixConfigResolver) LikelihoodLabels(ctx context.Context, obj *model.RiskMatrixConfig) ([]string, error) {
	panic(fmt.Errorf("not implemented: LikelihoodLabels - likelihoodLabels"))
}

// ImpactLabels is the resolver for the impactLabels field.
func (r *riskMatrixConfigResolver) ImpactLabels(ctx context.Context, obj *model.RiskMatrixConfig) ([]string, error) {
	panic(fmt.Errorf("not implemented: ImpactLabels - impactLabels"))
}

// LevelThresholds is the resolver for the levelThresholds field.
func (r *riskMatrixConfigResolver) LevelThresholds(ctx context.Context, obj *model.RiskMatrixConfig) (string, error) {
	panic(fmt.Errorf("not implemented: LevelThresholds - levelThresholds"))
}

// Responsible is the resolver for the responsible field.
func (r *riskTreatmentResolver) Responsible(ctx context.Context, obj *model.RiskTreatment) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Responsible - responsible"))
}

// Risk returns RiskResolver implementation.
func (r *Resolver) Risk() RiskResolver { return &riskResolver{r} }

// RiskMatrixConfig returns RiskMatrixConfigResolver implementation.
func (r *Resolver) RiskMatrixConfig() RiskMatrixConfigResolver { return &riskMatrixConfigResolver{r} }

// RiskTreatment returns RiskTreatmentResolver implementation.
func (r *Resolver) RiskTreatment() RiskTreatmentResolver { return &riskTreatmentResolver{r} }

type riskResolver struct{ *Resolver }
type riskMatrixConfigResolver struct{ *Resolver }
type riskTreatmentResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type RiskConnection struct {
	Edges      []*RiskEdge `json:"edges"`
	PageInfo   *PageInfo   `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}
type RiskEdge struct {
	Cursor string      `json:"cursor"`
	Node   *model.Risk `json:"node"`
}

func (r *Resolver) Risks(ctx context.Context, first *int, after *string, filter *repository.RiskFilter) (*RiskConnection, error) {
	params := paginationParams(first, after)
	var risks []*model.Risk
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		risks, pr, err = r.RiskRepo.List(ctx, tx, params, filter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*RiskEdge, len(risks))
	for i, risk := range risks {
		edges[i] = &RiskEdge{Cursor: repository.EncodeCursor(i), Node: risk}
	}
	return &RiskConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}
func (r *Resolver) CreateRisk(ctx context.Context, input CreateRiskInput) (*model.Risk, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	risk := &model.Risk{
		OrgID:              orgID,
		Title:              input.Title,
		Description:        derefStr(input.Description),
		Scenario:           derefStr(input.Scenario),
		Category:           derefStr(input.Category),
		Source:             derefStr(input.Source),
		InherentLikelihood: derefInt(input.InherentLikelihood),
		InherentImpact:     derefInt(input.InherentImpact),
		ResidualLikelihood: derefInt(input.ResidualLikelihood),
		ResidualImpact:     derefInt(input.ResidualImpact),
		Status:             "identified",
		OwnerID:            input.OwnerID,
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.Create(ctx, tx, risk)
	})
	return risk, err
}
func (r *Resolver) UpdateRisk(ctx context.Context, id string, input UpdateRiskInput) (*model.Risk, error) {
	var risk *model.Risk
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		risk, err = r.RiskRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Title != nil {
			risk.Title = *input.Title
		}
		if input.Description != nil {
			risk.Description = *input.Description
		}
		if input.Scenario != nil {
			risk.Scenario = *input.Scenario
		}
		if input.Category != nil {
			risk.Category = *input.Category
		}
		if input.InherentLikelihood != nil {
			risk.InherentLikelihood = *input.InherentLikelihood
		}
		if input.InherentImpact != nil {
			risk.InherentImpact = *input.InherentImpact
		}
		if input.ResidualLikelihood != nil {
			risk.ResidualLikelihood = *input.ResidualLikelihood
		}
		if input.ResidualImpact != nil {
			risk.ResidualImpact = *input.ResidualImpact
		}
		if input.Status != nil {
			risk.Status = *input.Status
		}
		if input.OwnerID != nil {
			risk.OwnerID = input.OwnerID
		}
		return r.RiskRepo.Update(ctx, tx, risk)
	})
	return risk, err
}
func (r *Resolver) DeleteRisk(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}
func (r *Resolver) CreateRiskTreatment(ctx context.Context, riskID string, input CreateTreatmentInput) (*model.RiskTreatment, error) {
	t := &model.RiskTreatment{
		RiskID:        riskID,
		Action:        input.Action,
		ResponsibleID: input.ResponsibleID,
		Deadline:      input.Deadline,
		Status:        "open",
	}
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.CreateTreatment(ctx, tx, t)
	})
	return t, err
}
func (r *Resolver) UpdateRiskTreatment(ctx context.Context, id string, input UpdateTreatmentInput) (*model.RiskTreatment, error) {
	var t *model.RiskTreatment
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		t, err = r.RiskRepo.GetTreatment(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Action != nil {
			t.Action = *input.Action
		}
		if input.ResponsibleID != nil {
			t.ResponsibleID = input.ResponsibleID
		}
		if input.Deadline != nil {
			t.Deadline = input.Deadline
		}
		if input.Status != nil {
			t.Status = *input.Status
		}
		return r.RiskRepo.UpdateTreatment(ctx, tx, t)
	})
	return t, err
}
func (r *Resolver) RiskTreatments(ctx context.Context, risk *model.Risk) ([]*model.RiskTreatment, error) {
	var treatments []*model.RiskTreatment
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		treatments, err = r.RiskRepo.ListTreatments(ctx, tx, risk.ID)
		return err
	})
	return treatments, err
}
func (r *Resolver) RiskHeatmap(ctx context.Context) ([]repository.HeatmapCell, error) {
	var cells []repository.HeatmapCell
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		cells, err = r.RiskRepo.GetHeatmapData(ctx, tx)
		return err
	})
	return cells, err
}
func (r *Resolver) RiskOwner(ctx context.Context, risk *model.Risk) (*model.User, error) {
	if risk.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *risk.OwnerID)
}
func (r *Resolver) RiskInherentLevel(risk *model.Risk) int {
	return risk.InherentLikelihood * risk.InherentImpact
}
func (r *Resolver) RiskResidualLevel(risk *model.Risk) int {
	return risk.ResidualLikelihood * risk.ResidualImpact
}
func derefInt(p *int) int {
	if p == nil {
		return 0
	}
	return *p
}

type CreateRiskInput struct {
	Title              string  `json:"title"`
	Description        *string `json:"description"`
	Scenario           *string `json:"scenario"`
	Category           *string `json:"category"`
	Source             *string `json:"source"`
	InherentLikelihood *int    `json:"inherentLikelihood"`
	InherentImpact     *int    `json:"inherentImpact"`
	ResidualLikelihood *int    `json:"residualLikelihood"`
	ResidualImpact     *int    `json:"residualImpact"`
	OwnerID            *string `json:"ownerId"`
}
type UpdateRiskInput struct {
	Title              *string `json:"title"`
	Description        *string `json:"description"`
	Scenario           *string `json:"scenario"`
	Category           *string `json:"category"`
	InherentLikelihood *int    `json:"inherentLikelihood"`
	InherentImpact     *int    `json:"inherentImpact"`
	ResidualLikelihood *int    `json:"residualLikelihood"`
	ResidualImpact     *int    `json:"residualImpact"`
	Status             *string `json:"status"`
	OwnerID            *string `json:"ownerId"`
}
type CreateTreatmentInput struct {
	Action        string     `json:"action"`
	ResponsibleID *string    `json:"responsibleId"`
	Deadline      *time.Time `json:"deadline"`
	Status        *string    `json:"status"`
}
type UpdateTreatmentInput struct {
	Action        *string    `json:"action"`
	ResponsibleID *string    `json:"responsibleId"`
	Deadline      *time.Time `json:"deadline"`
	Status        *string    `json:"status"`
}
