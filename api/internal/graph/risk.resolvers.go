package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"encoding/json"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/k1ngErr0r/ITSecBase/api/internal/auth"
	model1 "github.com/k1ngErr0r/ITSecBase/api/internal/graph/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/model"
	"github.com/k1ngErr0r/ITSecBase/api/internal/repository"
)

// CreateRisk is the resolver for the createRisk field.
func (r *mutationResolver) CreateRisk(ctx context.Context, input model1.CreateRiskInput) (*model.Risk, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	risk := &model.Risk{
		OrgID:              orgID,
		Title:              input.Title,
		Description:        derefStr(input.Description),
		Scenario:           derefStr(input.Scenario),
		Category:           derefStr(input.Category),
		Source:             derefStr(input.Source),
		InherentLikelihood: derefInt(input.InherentLikelihood),
		InherentImpact:     derefInt(input.InherentImpact),
		ResidualLikelihood: derefInt(input.ResidualLikelihood),
		ResidualImpact:     derefInt(input.ResidualImpact),
		Status:             "identified",
		OwnerID:            input.OwnerID,
		ApproverID:         input.ApproverID,
		ReviewDate:         input.ReviewDate,
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		if err := r.RiskRepo.Create(ctx, tx, risk); err != nil {
			return err
		}
		for _, aid := range input.AssetIds {
			if err := r.RiskRepo.LinkAsset(ctx, tx, risk.ID, aid); err != nil {
				return err
			}
		}
		for _, cid := range input.ControlIds {
			if err := r.RiskRepo.LinkControl(ctx, tx, risk.ID, cid); err != nil {
				return err
			}
		}
		return nil
	})
	return risk, err
}

// UpdateRisk is the resolver for the updateRisk field.
func (r *mutationResolver) UpdateRisk(ctx context.Context, id string, input model1.UpdateRiskInput) (*model.Risk, error) {
	var risk *model.Risk
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		risk, err = r.RiskRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Title != nil {
			risk.Title = *input.Title
		}
		if input.Description != nil {
			risk.Description = *input.Description
		}
		if input.Scenario != nil {
			risk.Scenario = *input.Scenario
		}
		if input.Category != nil {
			risk.Category = *input.Category
		}
		if input.Source != nil {
			risk.Source = *input.Source
		}
		if input.InherentLikelihood != nil {
			risk.InherentLikelihood = *input.InherentLikelihood
		}
		if input.InherentImpact != nil {
			risk.InherentImpact = *input.InherentImpact
		}
		if input.ResidualLikelihood != nil {
			risk.ResidualLikelihood = *input.ResidualLikelihood
		}
		if input.ResidualImpact != nil {
			risk.ResidualImpact = *input.ResidualImpact
		}
		if input.Status != nil {
			risk.Status = *input.Status
		}
		if input.OwnerID != nil {
			risk.OwnerID = input.OwnerID
		}
		if input.ApproverID != nil {
			risk.ApproverID = input.ApproverID
		}
		if input.ReviewDate != nil {
			risk.ReviewDate = input.ReviewDate
		}
		return r.RiskRepo.Update(ctx, tx, risk)
	})
	return risk, err
}

// DeleteRisk is the resolver for the deleteRisk field.
func (r *mutationResolver) DeleteRisk(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}

// AddRiskTreatment is the resolver for the addRiskTreatment field.
func (r *mutationResolver) AddRiskTreatment(ctx context.Context, riskID string, input model1.AddRiskTreatmentInput) (*model.RiskTreatment, error) {
	t := &model.RiskTreatment{
		RiskID:        riskID,
		Action:        input.Action,
		ResponsibleID: input.ResponsibleID,
		Deadline:      input.Deadline,
		Status:        "open",
	}
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.CreateTreatment(ctx, tx, t)
	})
	return t, err
}

// UpdateRiskTreatment is the resolver for the updateRiskTreatment field.
func (r *mutationResolver) UpdateRiskTreatment(ctx context.Context, id string, input model1.UpdateRiskTreatmentInput) (*model.RiskTreatment, error) {
	var t *model.RiskTreatment
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		t, err = r.RiskRepo.GetTreatment(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Action != nil {
			t.Action = *input.Action
		}
		if input.ResponsibleID != nil {
			t.ResponsibleID = input.ResponsibleID
		}
		if input.Deadline != nil {
			t.Deadline = input.Deadline
		}
		if input.Status != nil {
			t.Status = *input.Status
		}
		return r.RiskRepo.UpdateTreatment(ctx, tx, t)
	})
	return t, err
}

// UpdateRiskMatrixConfig is the resolver for the updateRiskMatrixConfig field.
func (r *mutationResolver) UpdateRiskMatrixConfig(ctx context.Context, input model1.UpdateRiskMatrixConfigInput) (*model.RiskMatrixConfig, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	likelihoodJSON, err := json.Marshal(input.LikelihoodLabels)
	if err != nil {
		return nil, fmt.Errorf("marshal likelihood labels: %w", err)
	}
	impactJSON, err := json.Marshal(input.ImpactLabels)
	if err != nil {
		return nil, fmt.Errorf("marshal impact labels: %w", err)
	}

	config := &model.RiskMatrixConfig{
		OrgID:            orgID,
		LikelihoodLabels: likelihoodJSON,
		ImpactLabels:     impactJSON,
		LevelThresholds:  json.RawMessage(input.LevelThresholds),
	}

	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.RiskRepo.UpdateMatrixConfig(ctx, tx, config)
	})
	return config, err
}

// Risks is the resolver for the risks field.
func (r *queryResolver) Risks(ctx context.Context, first *int, after *string, filter *model1.RiskFilter) (*model1.RiskConnection, error) {
	params := paginationParams(first, after)
	var repoFilter *repository.RiskFilter
	if filter != nil {
		repoFilter = &repository.RiskFilter{
			Status:   filter.Status,
			Category: filter.Category,
			OwnerID:  filter.OwnerID,
			Search:   filter.Search,
		}
	}

	var risks []*model.Risk
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		risks, pr, err = r.RiskRepo.List(ctx, tx, params, repoFilter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*model1.RiskEdge, len(risks))
	for i, risk := range risks {
		edges[i] = &model1.RiskEdge{Cursor: repository.EncodeCursor(i), Node: risk}
	}
	return &model1.RiskConnection{Edges: edges, PageInfo: toPageInfo(pr), TotalCount: pr.TotalCount}, nil
}

// Risk is the resolver for the risk field.
func (r *queryResolver) Risk(ctx context.Context, id string) (*model.Risk, error) {
	var risk *model.Risk
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		risk, err = r.RiskRepo.GetByID(ctx, tx, id)
		return err
	})
	return risk, err
}

// RiskMatrixConfig is the resolver for the riskMatrixConfig field.
func (r *queryResolver) RiskMatrixConfig(ctx context.Context) (*model.RiskMatrixConfig, error) {
	var config *model.RiskMatrixConfig
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		config, err = r.RiskRepo.GetMatrixConfig(ctx, tx)
		return err
	})
	return config, err
}

// CalculatedInherentLevel is the resolver for the calculatedInherentLevel field.
func (r *riskResolver) CalculatedInherentLevel(ctx context.Context, obj *model.Risk) (*string, error) {
	level := fmt.Sprintf("%d", obj.InherentLikelihood*obj.InherentImpact)
	return &level, nil
}

// CalculatedResidualLevel is the resolver for the calculatedResidualLevel field.
func (r *riskResolver) CalculatedResidualLevel(ctx context.Context, obj *model.Risk) (*string, error) {
	level := fmt.Sprintf("%d", obj.ResidualLikelihood*obj.ResidualImpact)
	return &level, nil
}

// Owner is the resolver for the owner field.
func (r *riskResolver) Owner(ctx context.Context, obj *model.Risk) (*model.User, error) {
	if obj.OwnerID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.OwnerID)
}

// Approver is the resolver for the approver field.
func (r *riskResolver) Approver(ctx context.Context, obj *model.Risk) (*model.User, error) {
	if obj.ApproverID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.ApproverID)
}

// LastReviewedBy is the resolver for the lastReviewedBy field.
func (r *riskResolver) LastReviewedBy(ctx context.Context, obj *model.Risk) (*model.User, error) {
	if obj.LastReviewedBy == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.LastReviewedBy)
}

// Assets is the resolver for the assets field.
func (r *riskResolver) Assets(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.AssetConnection, error) {
	var assetIDs []string
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		assetIDs, err = r.RiskRepo.GetLinkedAssetIDs(ctx, tx, obj.ID)
		return err
	})
	if err != nil || len(assetIDs) == 0 {
		return &model1.AssetConnection{Edges: []*model1.AssetEdge{}, PageInfo: &model1.PageInfo{}, TotalCount: 0}, nil
	}

	var assets []*model.Asset
	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		for _, id := range assetIDs {
			a, err := r.AssetRepo.GetByID(ctx, tx, id)
			if err != nil {
				continue
			}
			assets = append(assets, a)
		}
		return nil
	})

	edges := make([]*model1.AssetEdge, len(assets))
	for i, a := range assets {
		edges[i] = &model1.AssetEdge{Cursor: repository.EncodeCursor(i), Node: a}
	}
	return &model1.AssetConnection{Edges: edges, PageInfo: &model1.PageInfo{}, TotalCount: len(assets)}, nil
}

// Treatments is the resolver for the treatments field.
func (r *riskResolver) Treatments(ctx context.Context, obj *model.Risk) ([]*model.RiskTreatment, error) {
	var treatments []*model.RiskTreatment
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		treatments, err = r.RiskRepo.ListTreatments(ctx, tx, obj.ID)
		return err
	})
	return treatments, err
}

// Controls is the resolver for the controls field.
func (r *riskResolver) Controls(ctx context.Context, obj *model.Risk) ([]*model.OrgIsoControl, error) {
	var controlIDs []string
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		controlIDs, err = r.RiskRepo.GetLinkedControlIDs(ctx, tx, obj.ID)
		return err
	})
	if err != nil || len(controlIDs) == 0 {
		return []*model.OrgIsoControl{}, nil
	}

	var controls []*model.OrgIsoControl
	err = r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		for _, id := range controlIDs {
			c, err := r.IsoControlRepo.GetOrgControlByIsoControlID(ctx, tx, id)
			if err != nil {
				continue
			}
			controls = append(controls, c)
		}
		return nil
	})
	return controls, err
}

// Comments is the resolver for the comments field.
func (r *riskResolver) Comments(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.CommentConnection, error) {
	return r.entityComments(ctx, "risk", obj.ID, first, after)
}

// Evidence is the resolver for the evidence field.
func (r *riskResolver) Evidence(ctx context.Context, obj *model.Risk, first *int, after *string) (*model1.EvidenceConnection, error) {
	return r.entityEvidence(ctx, "risk", obj.ID, first, after)
}

// LikelihoodLabels is the resolver for the likelihoodLabels field.
func (r *riskMatrixConfigResolver) LikelihoodLabels(ctx context.Context, obj *model.RiskMatrixConfig) ([]string, error) {
	return jsonToStrings(obj.LikelihoodLabels)
}

// ImpactLabels is the resolver for the impactLabels field.
func (r *riskMatrixConfigResolver) ImpactLabels(ctx context.Context, obj *model.RiskMatrixConfig) ([]string, error) {
	return jsonToStrings(obj.ImpactLabels)
}

// LevelThresholds is the resolver for the levelThresholds field.
func (r *riskMatrixConfigResolver) LevelThresholds(ctx context.Context, obj *model.RiskMatrixConfig) (string, error) {
	if obj.LevelThresholds == nil {
		return "{}", nil
	}
	return string(obj.LevelThresholds), nil
}

// Responsible is the resolver for the responsible field.
func (r *riskTreatmentResolver) Responsible(ctx context.Context, obj *model.RiskTreatment) (*model.User, error) {
	if obj.ResponsibleID == nil {
		return nil, nil
	}
	return r.resolveUser(ctx, *obj.ResponsibleID)
}

// Risk returns RiskResolver implementation.
func (r *Resolver) Risk() RiskResolver { return &riskResolver{r} }

// RiskMatrixConfig returns RiskMatrixConfigResolver implementation.
func (r *Resolver) RiskMatrixConfig() RiskMatrixConfigResolver { return &riskMatrixConfigResolver{r} }

// RiskTreatment returns RiskTreatmentResolver implementation.
func (r *Resolver) RiskTreatment() RiskTreatmentResolver { return &riskTreatmentResolver{r} }

type riskResolver struct{ *Resolver }
type riskMatrixConfigResolver struct{ *Resolver }
type riskTreatmentResolver struct{ *Resolver }
