package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/auth"
	model1 "github.com/jmcintyre/secbase/api/internal/graph/model"
	"github.com/jmcintyre/secbase/api/internal/model"
	"github.com/jmcintyre/secbase/api/internal/repository"
)

// BusinessOwner is the resolver for the businessOwner field.
func (r *assetResolver) BusinessOwner(ctx context.Context, obj *model.Asset) (*model.User, error) {
	panic(fmt.Errorf("not implemented: BusinessOwner - businessOwner"))
}

// TechnicalOwner is the resolver for the technicalOwner field.
func (r *assetResolver) TechnicalOwner(ctx context.Context, obj *model.Asset) (*model.User, error) {
	panic(fmt.Errorf("not implemented: TechnicalOwner - technicalOwner"))
}

// Vulnerabilities is the resolver for the vulnerabilities field.
func (r *assetResolver) Vulnerabilities(ctx context.Context, obj *model.Asset, first *int, after *string) (*model1.VulnerabilityConnection, error) {
	panic(fmt.Errorf("not implemented: Vulnerabilities - vulnerabilities"))
}

// Comments is the resolver for the comments field.
func (r *assetResolver) Comments(ctx context.Context, obj *model.Asset, first *int, after *string) (*model1.CommentConnection, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// Evidence is the resolver for the evidence field.
func (r *assetResolver) Evidence(ctx context.Context, obj *model.Asset, first *int, after *string) (*model1.EvidenceConnection, error) {
	panic(fmt.Errorf("not implemented: Evidence - evidence"))
}

// Dependencies is the resolver for the dependencies field.
func (r *assetResolver) Dependencies(ctx context.Context, obj *model.Asset) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: Dependencies - dependencies"))
}

// CreateAsset is the resolver for the createAsset field.
func (r *mutationResolver) CreateAsset(ctx context.Context, input model1.CreateAssetInput) (*model.Asset, error) {
	panic(fmt.Errorf("not implemented: CreateAsset - createAsset"))
}

// UpdateAsset is the resolver for the updateAsset field.
func (r *mutationResolver) UpdateAsset(ctx context.Context, id string, input model1.UpdateAssetInput) (*model.Asset, error) {
	panic(fmt.Errorf("not implemented: UpdateAsset - updateAsset"))
}

// DeleteAsset is the resolver for the deleteAsset field.
func (r *mutationResolver) DeleteAsset(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAsset - deleteAsset"))
}

// Assets is the resolver for the assets field.
func (r *queryResolver) Assets(ctx context.Context, first *int, after *string, filter *model1.AssetFilter) (*model1.AssetConnection, error) {
	panic(fmt.Errorf("not implemented: Assets - assets"))
}

// Asset is the resolver for the asset field.
func (r *queryResolver) Asset(ctx context.Context, id string) (*model.Asset, error) {
	panic(fmt.Errorf("not implemented: Asset - asset"))
}

// Asset returns AssetResolver implementation.
func (r *Resolver) Asset() AssetResolver { return &assetResolver{r} }

type assetResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}
type AssetEdge struct {
	Cursor string       `json:"cursor"`
	Node   *model.Asset `json:"node"`
}

func (r *Resolver) Assets(ctx context.Context, first *int, after *string, filter *repository.AssetFilter) (*AssetConnection, error) {
	params := paginationParams(first, after)

	var assets []*model.Asset
	var pr repository.PaginationResult

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		assets, pr, err = r.AssetRepo.List(ctx, tx, params, filter)
		return err
	})
	if err != nil {
		return nil, err
	}

	edges := make([]*AssetEdge, len(assets))
	for i, a := range assets {
		edges[i] = &AssetEdge{
			Cursor: repository.EncodeCursor(i),
			Node:   a,
		}
	}

	return &AssetConnection{
		Edges:      edges,
		PageInfo:   toPageInfo(pr),
		TotalCount: pr.TotalCount,
	}, nil
}
func (r *Resolver) CreateAsset(ctx context.Context, input CreateAssetInput) (*model.Asset, error) {
	orgID, ok := auth.OrgIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	a := &model.Asset{
		OrgID:     orgID,
		Name:      input.Name,
		AssetType: input.AssetType,
		Status:    "in_use",
	}

	if input.Make != nil {
		a.Make = *input.Make
	}
	if input.Model != nil {
		a.Model = *input.Model
	}
	if input.Version != nil {
		a.Version = *input.Version
	}
	a.BusinessOwnerID = input.BusinessOwnerID
	a.TechnicalOwnerID = input.TechnicalOwnerID
	if input.IPAddresses != nil {
		a.IPAddresses = input.IPAddresses
	}
	if input.Hostnames != nil {
		a.Hostnames = input.Hostnames
	}
	if input.FQDN != nil {
		a.FQDN = *input.FQDN
	}
	if input.URL != nil {
		a.URL = *input.URL
	}
	if input.LocationSite != nil {
		a.LocationSite = *input.LocationSite
	}
	if input.LocationDetail != nil {
		a.LocationDetail = *input.LocationDetail
	}
	if input.Environment != nil {
		a.Environment = *input.Environment
	}
	if input.Criticality != nil {
		a.Criticality = *input.Criticality
	}
	if input.DataClassification != nil {
		a.DataClassification = *input.DataClassification
	}
	if input.Tags != nil {
		a.Tags = input.Tags
	}

	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.AssetRepo.Create(ctx, tx, a)
	})
	return a, err
}
func (r *Resolver) UpdateAsset(ctx context.Context, id string, input UpdateAssetInput) (*model.Asset, error) {
	var a *model.Asset
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		a, err = r.AssetRepo.GetByID(ctx, tx, id)
		if err != nil {
			return err
		}
		if input.Name != nil {
			a.Name = *input.Name
		}
		if input.AssetType != nil {
			a.AssetType = *input.AssetType
		}
		if input.Make != nil {
			a.Make = *input.Make
		}
		if input.Model != nil {
			a.Model = *input.Model
		}
		if input.Version != nil {
			a.Version = *input.Version
		}
		if input.BusinessOwnerID != nil {
			a.BusinessOwnerID = input.BusinessOwnerID
		}
		if input.TechnicalOwnerID != nil {
			a.TechnicalOwnerID = input.TechnicalOwnerID
		}
		if input.IPAddresses != nil {
			a.IPAddresses = input.IPAddresses
		}
		if input.Hostnames != nil {
			a.Hostnames = input.Hostnames
		}
		if input.FQDN != nil {
			a.FQDN = *input.FQDN
		}
		if input.URL != nil {
			a.URL = *input.URL
		}
		if input.LocationSite != nil {
			a.LocationSite = *input.LocationSite
		}
		if input.LocationDetail != nil {
			a.LocationDetail = *input.LocationDetail
		}
		if input.Environment != nil {
			a.Environment = *input.Environment
		}
		if input.Criticality != nil {
			a.Criticality = *input.Criticality
		}
		if input.DataClassification != nil {
			a.DataClassification = *input.DataClassification
		}
		if input.Tags != nil {
			a.Tags = input.Tags
		}
		if input.Status != nil {
			a.Status = *input.Status
		}
		return r.AssetRepo.Update(ctx, tx, a)
	})
	return a, err
}
func (r *Resolver) DeleteAsset(ctx context.Context, id string) (bool, error) {
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		return r.AssetRepo.Delete(ctx, tx, id)
	})
	return err == nil, err
}
func (r *Resolver) AssetBusinessOwner(ctx context.Context, asset *model.Asset) (*model.User, error) {
	if asset.BusinessOwnerID == nil {
		return nil, nil
	}
	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, *asset.BusinessOwnerID)
		return err
	})
	return user, err
}
func (r *Resolver) AssetTechnicalOwner(ctx context.Context, asset *model.Asset) (*model.User, error) {
	if asset.TechnicalOwnerID == nil {
		return nil, nil
	}
	var user *model.User
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		user, err = r.UserRepo.GetByID(ctx, tx, *asset.TechnicalOwnerID)
		return err
	})
	return user, err
}
func (r *Resolver) AssetDependencies(ctx context.Context, asset *model.Asset) ([]*model.Asset, error) {
	var deps []*model.Asset
	err := r.DB.WithTx(ctx, func(tx pgx.Tx) error {
		var err error
		deps, err = r.AssetRepo.GetDependencies(ctx, tx, asset.ID)
		return err
	})
	return deps, err
}

type CreateAssetInput struct {
	Name               string   `json:"name"`
	AssetType          string   `json:"assetType"`
	Make               *string  `json:"make"`
	Model              *string  `json:"model"`
	Version            *string  `json:"version"`
	BusinessOwnerID    *string  `json:"businessOwnerId"`
	TechnicalOwnerID   *string  `json:"technicalOwnerId"`
	IPAddresses        []string `json:"ipAddresses"`
	Hostnames          []string `json:"hostnames"`
	FQDN               *string  `json:"fqdn"`
	URL                *string  `json:"url"`
	LocationSite       *string  `json:"locationSite"`
	LocationDetail     *string  `json:"locationDetail"`
	Environment        *string  `json:"environment"`
	Criticality        *int     `json:"criticality"`
	DataClassification *string  `json:"dataClassification"`
	Tags               []string `json:"tags"`
}
type UpdateAssetInput struct {
	Name               *string  `json:"name"`
	AssetType          *string  `json:"assetType"`
	Make               *string  `json:"make"`
	Model              *string  `json:"model"`
	Version            *string  `json:"version"`
	BusinessOwnerID    *string  `json:"businessOwnerId"`
	TechnicalOwnerID   *string  `json:"technicalOwnerId"`
	IPAddresses        []string `json:"ipAddresses"`
	Hostnames          []string `json:"hostnames"`
	FQDN               *string  `json:"fqdn"`
	URL                *string  `json:"url"`
	LocationSite       *string  `json:"locationSite"`
	LocationDetail     *string  `json:"locationDetail"`
	Environment        *string  `json:"environment"`
	Criticality        *int     `json:"criticality"`
	DataClassification *string  `json:"dataClassification"`
	Tags               []string `json:"tags"`
	Status             *string  `json:"status"`
}
