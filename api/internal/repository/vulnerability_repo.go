package repository

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/k1ngErr0r/ITSecBase/api/internal/model"
)

type VulnerabilityRepo struct{}

func NewVulnerabilityRepo() *VulnerabilityRepo {
	return &VulnerabilityRepo{}
}

func (r *VulnerabilityRepo) GetByID(ctx context.Context, tx pgx.Tx, id string) (*model.Vulnerability, error) {
	v := &model.Vulnerability{}
	err := tx.QueryRow(ctx, `
		SELECT id, org_id, title, description, source, cve_ids, external_refs,
		       cvss_score, cvss_vector, severity, status, discovery_date, due_date,
		       closure_date, owner_id, analyst_id, approver_id, tags, notes,
		       created_at, updated_at
		FROM vulnerabilities WHERE id = $1
	`, id).Scan(
		&v.ID, &v.OrgID, &v.Title, &v.Description, &v.Source, &v.CVEIDs, &v.ExternalRefs,
		&v.CVSSScore, &v.CVSSVector, &v.Severity, &v.Status, &v.DiscoveryDate, &v.DueDate,
		&v.ClosureDate, &v.OwnerID, &v.AnalystID, &v.ApproverID, &v.Tags, &v.Notes,
		&v.CreatedAt, &v.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("get vulnerability: %w", err)
	}
	return v, nil
}

func (r *VulnerabilityRepo) List(ctx context.Context, tx pgx.Tx, params PaginationParams, filter *VulnFilter) ([]*model.Vulnerability, PaginationResult, error) {
	limit := NormalizeFirst(&params.First)
	offset, err := DecodeCursor(params.After)
	if err != nil {
		return nil, PaginationResult{}, err
	}

	where := "WHERE 1=1"
	args := []any{}
	argIdx := 1

	if filter != nil {
		if filter.Severity != nil {
			where += fmt.Sprintf(" AND severity = $%d", argIdx)
			args = append(args, *filter.Severity)
			argIdx++
		}
		if filter.Status != nil {
			where += fmt.Sprintf(" AND status = $%d", argIdx)
			args = append(args, *filter.Status)
			argIdx++
		}
		if filter.Source != nil {
			where += fmt.Sprintf(" AND source = $%d", argIdx)
			args = append(args, *filter.Source)
			argIdx++
		}
		if filter.OwnerID != nil {
			where += fmt.Sprintf(" AND owner_id = $%d", argIdx)
			args = append(args, *filter.OwnerID)
			argIdx++
		}
		if filter.AssetID != nil {
			where += fmt.Sprintf(" AND id IN (SELECT vulnerability_id FROM vulnerability_assets WHERE asset_id = $%d)", argIdx)
			args = append(args, *filter.AssetID)
			argIdx++
		}
		if filter.Search != nil {
			where += fmt.Sprintf(" AND (title ILIKE $%d OR description ILIKE $%d)", argIdx, argIdx)
			args = append(args, "%"+*filter.Search+"%")
			argIdx++
		}
		if filter.CveID != nil {
			where += fmt.Sprintf(" AND $%d = ANY(cve_ids)", argIdx)
			args = append(args, *filter.CveID)
			argIdx++
		}
	}

	var totalCount int
	if err := tx.QueryRow(ctx, fmt.Sprintf("SELECT COUNT(*) FROM vulnerabilities %s", where), args...).Scan(&totalCount); err != nil {
		return nil, PaginationResult{}, err
	}

	query := fmt.Sprintf(`
		SELECT id, org_id, title, description, source, cve_ids, external_refs,
		       cvss_score, cvss_vector, severity, status, discovery_date, due_date,
		       closure_date, owner_id, analyst_id, approver_id, tags, notes,
		       created_at, updated_at
		FROM vulnerabilities %s
		ORDER BY created_at DESC LIMIT $%d OFFSET $%d
	`, where, argIdx, argIdx+1)
	args = append(args, limit+1, offset)

	rows, err := tx.Query(ctx, query, args...)
	if err != nil {
		return nil, PaginationResult{}, err
	}
	defer rows.Close()

	var vulns []*model.Vulnerability
	for rows.Next() {
		v := &model.Vulnerability{}
		if err := rows.Scan(
			&v.ID, &v.OrgID, &v.Title, &v.Description, &v.Source, &v.CVEIDs, &v.ExternalRefs,
			&v.CVSSScore, &v.CVSSVector, &v.Severity, &v.Status, &v.DiscoveryDate, &v.DueDate,
			&v.ClosureDate, &v.OwnerID, &v.AnalystID, &v.ApproverID, &v.Tags, &v.Notes,
			&v.CreatedAt, &v.UpdatedAt,
		); err != nil {
			return nil, PaginationResult{}, err
		}
		vulns = append(vulns, v)
	}

	hasNext := len(vulns) > limit
	if hasNext {
		vulns = vulns[:limit]
	}

	result := PaginationResult{
		HasNextPage:     hasNext,
		HasPreviousPage: offset > 0,
		TotalCount:      totalCount,
	}
	if len(vulns) > 0 {
		result.StartCursor = EncodeCursor(offset)
		result.EndCursor = EncodeCursor(offset + len(vulns) - 1)
	}
	return vulns, result, nil
}

func (r *VulnerabilityRepo) Create(ctx context.Context, tx pgx.Tx, v *model.Vulnerability) error {
	err := tx.QueryRow(ctx, `
		INSERT INTO vulnerabilities (
			org_id, title, description, source, cve_ids, external_refs,
			cvss_score, cvss_vector, severity, status, discovery_date, due_date,
			owner_id, analyst_id, approver_id, tags, notes
		) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
		RETURNING id, created_at, updated_at
	`, v.OrgID, v.Title, v.Description, v.Source, v.CVEIDs, v.ExternalRefs,
		v.CVSSScore, v.CVSSVector, v.Severity, v.Status, v.DiscoveryDate, v.DueDate,
		v.OwnerID, v.AnalystID, v.ApproverID, v.Tags, v.Notes,
	).Scan(&v.ID, &v.CreatedAt, &v.UpdatedAt)
	return err
}

func (r *VulnerabilityRepo) Update(ctx context.Context, tx pgx.Tx, v *model.Vulnerability) error {
	_, err := tx.Exec(ctx, `
		UPDATE vulnerabilities SET
			title=$2, description=$3, source=$4, cve_ids=$5, external_refs=$6,
			cvss_score=$7, cvss_vector=$8, severity=$9, status=$10, discovery_date=$11,
			due_date=$12, closure_date=$13, owner_id=$14, analyst_id=$15, approver_id=$16,
			tags=$17, notes=$18, updated_at=now()
		WHERE id = $1
	`, v.ID, v.Title, v.Description, v.Source, v.CVEIDs, v.ExternalRefs,
		v.CVSSScore, v.CVSSVector, v.Severity, v.Status, v.DiscoveryDate,
		v.DueDate, v.ClosureDate, v.OwnerID, v.AnalystID, v.ApproverID,
		v.Tags, v.Notes,
	)
	return err
}

func (r *VulnerabilityRepo) Delete(ctx context.Context, tx pgx.Tx, id string) error {
	_, err := tx.Exec(ctx, `DELETE FROM vulnerabilities WHERE id = $1`, id)
	return err
}

func (r *VulnerabilityRepo) LinkAsset(ctx context.Context, tx pgx.Tx, vulnID, assetID string) error {
	_, err := tx.Exec(ctx, `INSERT INTO vulnerability_assets (vulnerability_id, asset_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`, vulnID, assetID)
	return err
}

func (r *VulnerabilityRepo) UnlinkAsset(ctx context.Context, tx pgx.Tx, vulnID, assetID string) error {
	_, err := tx.Exec(ctx, `DELETE FROM vulnerability_assets WHERE vulnerability_id = $1 AND asset_id = $2`, vulnID, assetID)
	return err
}

func (r *VulnerabilityRepo) GetAssetIDs(ctx context.Context, tx pgx.Tx, vulnID string) ([]string, error) {
	rows, err := tx.Query(ctx, `SELECT asset_id FROM vulnerability_assets WHERE vulnerability_id = $1`, vulnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	return ids, nil
}

func (r *VulnerabilityRepo) ListByAsset(ctx context.Context, tx pgx.Tx, assetID string, params PaginationParams) ([]*model.Vulnerability, PaginationResult, error) {
	filter := &VulnFilter{AssetID: &assetID}
	return r.List(ctx, tx, params, filter)
}

func (r *VulnerabilityRepo) RecordHistory(ctx context.Context, tx pgx.Tx, h *model.VulnerabilityHistory) error {
	_, err := tx.Exec(ctx, `
		INSERT INTO vulnerability_history (vulnerability_id, changed_by, field_name, old_value, new_value)
		VALUES ($1, $2, $3, $4, $5)
	`, h.VulnerabilityID, h.ChangedBy, h.FieldName, h.OldValue, h.NewValue)
	return err
}

func (r *VulnerabilityRepo) GetHistory(ctx context.Context, tx pgx.Tx, vulnID string) ([]*model.VulnerabilityHistory, error) {
	rows, err := tx.Query(ctx, `
		SELECT id, vulnerability_id, changed_by, field_name, old_value, new_value, changed_at
		FROM vulnerability_history WHERE vulnerability_id = $1 ORDER BY changed_at DESC
	`, vulnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var history []*model.VulnerabilityHistory
	for rows.Next() {
		h := &model.VulnerabilityHistory{}
		if err := rows.Scan(&h.ID, &h.VulnerabilityID, &h.ChangedBy, &h.FieldName, &h.OldValue, &h.NewValue, &h.ChangedAt); err != nil {
			return nil, err
		}
		history = append(history, h)
	}
	return history, nil
}

func (r *VulnerabilityRepo) BulkUpdateStatus(ctx context.Context, tx pgx.Tx, ids []string, status string) error {
	_, err := tx.Exec(ctx, `UPDATE vulnerabilities SET status = $1, updated_at = now() WHERE id = ANY($2)`, status, ids)
	return err
}

type VulnFilter struct {
	Severity *string
	Status   *string
	Source   *string
	OwnerID  *string
	AssetID  *string
	Search   *string
	CveID    *string
}
