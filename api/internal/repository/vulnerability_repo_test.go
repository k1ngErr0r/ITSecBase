package repository

import (
	"encoding/json"
	"testing"

	"github.com/jackc/pgx/v5"
	"github.com/jmcintyre/secbase/api/internal/model"
)

func TestVulnRepo_CreateAndGetByID(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		score := 9.8
		v := &model.Vulnerability{
			OrgID:       orgID,
			Title:       "SQL Injection",
			Description: "Found SQL injection in login",
			Source:      "pentest",
			Severity:    "critical",
			Status:      "new",
			CVEIDs:      []string{"CVE-2024-0001"},
			CVSSScore:   &score,
			CVSSVector:  "CVSS:3.1/AV:N/AC:L",
			Tags:        []string{"web", "owasp"},
		}
		if err := repo.Create(ctx, tx, v); err != nil {
			return err
		}
		if v.ID == "" {
			t.Error("expected ID to be set")
		}

		got, err := repo.GetByID(ctx, tx, v.ID)
		if err != nil {
			return err
		}
		if got.Title != "SQL Injection" {
			t.Errorf("Title = %q, want %q", got.Title, "SQL Injection")
		}
		if got.Severity != "critical" {
			t.Errorf("Severity = %q, want %q", got.Severity, "critical")
		}
		if got.CVSSScore == nil || *got.CVSSScore != 9.8 {
			t.Errorf("CVSSScore = %v, want 9.8", got.CVSSScore)
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_ListWithFilters(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		vulns := []*model.Vulnerability{
			{OrgID: orgID, Title: "Vuln 1", Severity: "critical", Status: "new", Source: "scan"},
			{OrgID: orgID, Title: "Vuln 2", Severity: "high", Status: "new", Source: "scan"},
			{OrgID: orgID, Title: "Vuln 3", Severity: "critical", Status: "mitigated", Source: "pentest"},
		}
		for _, v := range vulns {
			if err := repo.Create(ctx, tx, v); err != nil {
				return err
			}
		}

		sev := "critical"
		results, pr, err := repo.List(ctx, tx, PaginationParams{First: 10}, &VulnFilter{Severity: &sev})
		if err != nil {
			return err
		}
		if len(results) != 2 {
			t.Errorf("critical filter: got %d, want 2", len(results))
		}
		if pr.TotalCount != 2 {
			t.Errorf("TotalCount = %d, want 2", pr.TotalCount)
		}

		status := "new"
		results2, _, err := repo.List(ctx, tx, PaginationParams{First: 10}, &VulnFilter{Status: &status})
		if err != nil {
			return err
		}
		if len(results2) != 2 {
			t.Errorf("status filter: got %d, want 2", len(results2))
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_Update(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		v := &model.Vulnerability{OrgID: orgID, Title: "Before", Severity: "high", Status: "new"}
		if err := repo.Create(ctx, tx, v); err != nil {
			return err
		}
		v.Title = "After"
		v.Status = "mitigated"
		v.ExternalRefs = json.RawMessage(`{"url":"https://example.com"}`)
		if err := repo.Update(ctx, tx, v); err != nil {
			return err
		}
		got, err := repo.GetByID(ctx, tx, v.ID)
		if err != nil {
			return err
		}
		if got.Title != "After" {
			t.Errorf("Title = %q, want %q", got.Title, "After")
		}
		if got.Status != "mitigated" {
			t.Errorf("Status = %q, want %q", got.Status, "mitigated")
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_Delete(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		v := &model.Vulnerability{OrgID: orgID, Title: "ToDelete", Severity: "low", Status: "new"}
		if err := repo.Create(ctx, tx, v); err != nil {
			return err
		}
		if err := repo.Delete(ctx, tx, v.ID); err != nil {
			return err
		}
		_, err := repo.GetByID(ctx, tx, v.ID)
		if err == nil {
			t.Error("expected error after deleting vulnerability")
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_LinkAssetAndGetAssetIDs(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	vulnRepo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		v := &model.Vulnerability{OrgID: orgID, Title: "LinkedVuln", Severity: "high", Status: "new"}
		if err := vulnRepo.Create(ctx, tx, v); err != nil {
			return err
		}
		a := createTestAsset(t, ctx, tx, orgID, "Linked Asset")

		if err := vulnRepo.LinkAsset(ctx, tx, v.ID, a.ID); err != nil {
			return err
		}

		ids, err := vulnRepo.GetAssetIDs(ctx, tx, v.ID)
		if err != nil {
			return err
		}
		if len(ids) != 1 {
			t.Errorf("GetAssetIDs returned %d, want 1", len(ids))
		}
		if ids[0] != a.ID {
			t.Errorf("GetAssetIDs[0] = %s, want %s", ids[0], a.ID)
		}

		// Unlink
		if err := vulnRepo.UnlinkAsset(ctx, tx, v.ID, a.ID); err != nil {
			return err
		}
		ids2, err := vulnRepo.GetAssetIDs(ctx, tx, v.ID)
		if err != nil {
			return err
		}
		if len(ids2) != 0 {
			t.Errorf("after unlink, GetAssetIDs returned %d, want 0", len(ids2))
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_BulkUpdateStatus(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		v1 := &model.Vulnerability{OrgID: orgID, Title: "Bulk1", Severity: "high", Status: "new"}
		v2 := &model.Vulnerability{OrgID: orgID, Title: "Bulk2", Severity: "high", Status: "new"}
		if err := repo.Create(ctx, tx, v1); err != nil {
			return err
		}
		if err := repo.Create(ctx, tx, v2); err != nil {
			return err
		}

		if err := repo.BulkUpdateStatus(ctx, tx, []string{v1.ID, v2.ID}, "mitigated"); err != nil {
			return err
		}

		got1, err := repo.GetByID(ctx, tx, v1.ID)
		if err != nil {
			return err
		}
		got2, err := repo.GetByID(ctx, tx, v2.ID)
		if err != nil {
			return err
		}
		if got1.Status != "mitigated" {
			t.Errorf("v1 Status = %q, want %q", got1.Status, "mitigated")
		}
		if got2.Status != "mitigated" {
			t.Errorf("v2 Status = %q, want %q", got2.Status, "mitigated")
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestVulnRepo_RecordAndGetHistory(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}
	orgID, ctx := setupTestOrg(t)
	repo := NewVulnerabilityRepo()

	err := testDB.WithTx(ctx, func(tx pgx.Tx) error {
		v := &model.Vulnerability{OrgID: orgID, Title: "HistVuln", Severity: "high", Status: "new"}
		if err := repo.Create(ctx, tx, v); err != nil {
			return err
		}
		u := createTestUser(t, ctx, tx, orgID, "historian@ex.com")

		h := &model.VulnerabilityHistory{
			VulnerabilityID: v.ID,
			ChangedBy:       u.ID,
			FieldName:       "status",
			OldValue:        "new",
			NewValue:        "triaged",
		}
		if err := repo.RecordHistory(ctx, tx, h); err != nil {
			return err
		}

		history, err := repo.GetHistory(ctx, tx, v.ID)
		if err != nil {
			return err
		}
		if len(history) != 1 {
			t.Errorf("GetHistory returned %d entries, want 1", len(history))
		}
		if history[0].FieldName != "status" {
			t.Errorf("FieldName = %q, want %q", history[0].FieldName, "status")
		}
		if history[0].OldValue != "new" {
			t.Errorf("OldValue = %q, want %q", history[0].OldValue, "new")
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}
